--- a/third_party/webrtc/modules/video_coding/codecs/interface/libvpx_interface.h
+++ b/third_party/webrtc/modules/video_coding/codecs/interface/libvpx_interface.h
@@ -84,9 +84,6 @@ class LibvpxInterface {
   virtual vpx_codec_err_t codec_control(vpx_codec_ctx_t* ctx,
                                         vp8e_enc_control_id ctrl_id,
                                         vpx_svc_extra_cfg_t* param) const = 0;
-  virtual vpx_codec_err_t codec_control(vpx_codec_ctx_t* ctx,
-                                        vp8e_enc_control_id ctrl_id,
-                                        vpx_svc_frame_drop_t* param) const = 0;
   virtual vpx_codec_err_t codec_control(vpx_codec_ctx_t* ctx,
                                         vp8e_enc_control_id ctrl_id,
                                         void* param) const = 0;
@@ -97,10 +94,6 @@ class LibvpxInterface {
       vpx_codec_ctx_t* ctx,
       vp8e_enc_control_id ctrl_id,
       vpx_svc_ref_frame_config_t* param) const = 0;
-  virtual vpx_codec_err_t codec_control(
-      vpx_codec_ctx_t* ctx,
-      vp8e_enc_control_id ctrl_id,
-      vpx_svc_spatial_layer_sync_t* param) const = 0;
   virtual vpx_codec_err_t codec_control(vpx_codec_ctx_t* ctx,
                                         vp8e_enc_control_id ctrl_id,
                                         vpx_rc_funcs_t* param) const = 0;
--- a/third_party/webrtc/modules/video_coding/codecs/interface/libvpx_interface.cc
+++ b/third_party/webrtc/modules/video_coding/codecs/interface/libvpx_interface.cc
@@ -97,8 +97,6 @@ class LibvpxFacade : public LibvpxInterface {
         return vpx_codec_control(ctx, VP8E_SET_CQ_LEVEL, param);
       case VP8E_SET_MAX_INTRA_BITRATE_PCT:
         return vpx_codec_control(ctx, VP8E_SET_MAX_INTRA_BITRATE_PCT, param);
-      case VP9E_SET_MAX_INTER_BITRATE_PCT:
-        return vpx_codec_control(ctx, VP9E_SET_MAX_INTER_BITRATE_PCT, param);
       case VP8E_SET_GF_CBR_BOOST_PCT:
         return vpx_codec_control(ctx, VP8E_SET_GF_CBR_BOOST_PCT, param);
       case VP8E_SET_SCREEN_CONTENT_MODE:
@@ -126,12 +124,6 @@ class LibvpxFacade : public LibvpxInterface {
       case VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST:
         return vpx_codec_control(ctx, VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST,
                                  param);
-      case VP9E_SET_SVC_INTER_LAYER_PRED:
-        return vpx_codec_control(ctx, VP9E_SET_SVC_INTER_LAYER_PRED, param);
-      case VP9E_SET_SVC_GF_TEMPORAL_REF:
-        return vpx_codec_control(ctx, VP9E_SET_SVC_GF_TEMPORAL_REF, param);
-      case VP9E_SET_POSTENCODE_DROP:
-        return vpx_codec_control(ctx, VP9E_SET_POSTENCODE_DROP, param);
       default:
         RTC_NOTREACHED() << "Unsupported libvpx ctrl_id: " << ctrl_id;
     }
@@ -146,8 +138,6 @@ class LibvpxFacade : public LibvpxInterface {
         return vpx_codec_control(ctx, VP8E_SET_FRAME_FLAGS, param);
       case VP8E_SET_TEMPORAL_LAYER_ID:
         return vpx_codec_control(ctx, VP8E_SET_TEMPORAL_LAYER_ID, param);
-      case VP9E_SET_SVC:
-        return vpx_codec_control(ctx, VP9E_SET_SVC, param);
       case VP8E_SET_CPUUSED:
         return vpx_codec_control(ctx, VP8E_SET_CPUUSED, param);
       case VP8E_SET_TOKEN_PARTITIONS:
@@ -158,8 +148,6 @@ class LibvpxFacade : public LibvpxInterface {
         return vpx_codec_control(ctx, VP9E_SET_TILE_COLUMNS, param);
       case VP9E_SET_TILE_ROWS:
         return vpx_codec_control(ctx, VP9E_SET_TILE_ROWS, param);
-      case VP9E_SET_TPL:
-        return vpx_codec_control(ctx, VP9E_SET_TPL, param);
       case VP9E_SET_ALT_REF_AQ:
         return vpx_codec_control(ctx, VP9E_SET_ALT_REF_AQ, param);
       case VP9E_SET_TUNE_CONTENT:
@@ -168,8 +156,6 @@ class LibvpxFacade : public LibvpxInterface {
         return vpx_codec_control(ctx, VP9E_SET_COLOR_SPACE, param);
       case VP9E_SET_COLOR_RANGE:
         return vpx_codec_control(ctx, VP9E_SET_COLOR_RANGE, param);
-      case VP9E_SET_DELTA_Q_UV:
-        return vpx_codec_control(ctx, VP9E_SET_DELTA_Q_UV, param);
 
       default:
         if (param >= 0) {
@@ -203,10 +189,6 @@ class LibvpxFacade : public LibvpxInterface {
                                 vp8e_enc_control_id ctrl_id,
                                 vpx_roi_map* param) const override {
     switch (ctrl_id) {
-      case VP8E_SET_ROI_MAP:
-        return vpx_codec_control(ctx, VP8E_SET_ROI_MAP, param);
-      case VP9E_SET_ROI_MAP:
-        return vpx_codec_control(ctx, VP9E_SET_ROI_MAP, param);
       default:
         RTC_NOTREACHED() << "Unsupported libvpx ctrl_id: " << ctrl_id;
     }
@@ -251,18 +233,6 @@ class LibvpxFacade : public LibvpxInterface {
     return VPX_CODEC_ERROR;
   }
 
-  vpx_codec_err_t codec_control(vpx_codec_ctx_t* ctx,
-                                vp8e_enc_control_id ctrl_id,
-                                vpx_svc_frame_drop_t* param) const override {
-    switch (ctrl_id) {
-      case VP9E_SET_SVC_FRAME_DROP_LAYER:
-        return vpx_codec_control_(ctx, VP9E_SET_SVC_FRAME_DROP_LAYER, param);
-      default:
-        RTC_NOTREACHED() << "Unsupported libvpx ctrl_id: " << ctrl_id;
-    }
-    return VPX_CODEC_ERROR;
-  }
-
   vpx_codec_err_t codec_control(vpx_codec_ctx_t* ctx,
                                 vp8e_enc_control_id ctrl_id,
                                 void* param) const override {
@@ -298,21 +268,6 @@ class LibvpxFacade : public LibvpxInterface {
     switch (ctrl_id) {
       case VP9E_SET_SVC_REF_FRAME_CONFIG:
         return vpx_codec_control_(ctx, VP9E_SET_SVC_REF_FRAME_CONFIG, param);
-      case VP9E_GET_SVC_REF_FRAME_CONFIG:
-        return vpx_codec_control_(ctx, VP9E_GET_SVC_REF_FRAME_CONFIG, param);
-      default:
-        RTC_NOTREACHED() << "Unsupported libvpx ctrl_id: " << ctrl_id;
-    }
-    return VPX_CODEC_ERROR;
-  }
-
-  vpx_codec_err_t codec_control(
-      vpx_codec_ctx_t* ctx,
-      vp8e_enc_control_id ctrl_id,
-      vpx_svc_spatial_layer_sync_t* param) const override {
-    switch (ctrl_id) {
-      case VP9E_SET_SVC_SPATIAL_LAYER_SYNC:
-        return vpx_codec_control_(ctx, VP9E_SET_SVC_SPATIAL_LAYER_SYNC, param);
       default:
         RTC_NOTREACHED() << "Unsupported libvpx ctrl_id: " << ctrl_id;
     }
--- a/media/video/vpx_video_encoder.cc
+++ b/media/video/vpx_video_encoder.cc
@@ -319,28 +319,14 @@ void VpxVideoEncoder::Encode(scoped_refptr<VideoFrame> frame,
       NOTREACHED();
       break;
     default:
-      vpx_img_fmt_t fmt = frame->format() == PIXEL_FORMAT_NV12
-                              ? VPX_IMG_FMT_NV12
-                              : VPX_IMG_FMT_I420;
+      vpx_img_fmt_t fmt = VPX_IMG_FMT_I420;
       Status status = ReallocateVpxImageIfNeeded(
           &vpx_image_, fmt, codec_config_.g_w, codec_config_.g_h);
       if (!status.is_ok()) {
         std::move(done_cb).Run(status);
         return;
       }
-      if (fmt == VPX_IMG_FMT_NV12) {
-        vpx_image_.planes[VPX_PLANE_Y] =
-            const_cast<uint8_t*>(frame->visible_data(VideoFrame::kYPlane));
-        vpx_image_.planes[VPX_PLANE_U] =
-            const_cast<uint8_t*>(frame->visible_data(VideoFrame::kUVPlane));
-        // In NV12 Y and U samples are combined in one plane (bytes go YUYUYU),
-        // but libvpx treats them as two planes with the same stride but shifted
-        // by one byte.
-        vpx_image_.planes[VPX_PLANE_V] = vpx_image_.planes[VPX_PLANE_U] + 1;
-        vpx_image_.stride[VPX_PLANE_Y] = frame->stride(VideoFrame::kYPlane);
-        vpx_image_.stride[VPX_PLANE_U] = frame->stride(VideoFrame::kUVPlane);
-        vpx_image_.stride[VPX_PLANE_V] = frame->stride(VideoFrame::kUVPlane);
-      } else {
+      {
         vpx_image_.planes[VPX_PLANE_Y] =
             const_cast<uint8_t*>(frame->visible_data(VideoFrame::kYPlane));
         vpx_image_.planes[VPX_PLANE_U] =
--- a/third_party/webrtc/modules/video_coding/codecs/vp8/libvpx_vp8_encoder.cc
+++ b/third_party/webrtc/modules/video_coding/codecs/vp8/libvpx_vp8_encoder.cc
@@ -954,9 +954,6 @@ int LibvpxVp8Encoder::Encode(const Video
     case VideoFrameBuffer::Type::kI420:
       PrepareI420Image(input_image->GetI420());
       break;
-    case VideoFrameBuffer::Type::kNV12:
-      PrepareNV12Image(input_image->GetNV12());
-      break;
     default: {
       rtc::scoped_refptr<I420BufferInterface> i420_image =
           input_image->ToI420();
@@ -1062,25 +1062,9 @@ void LibvpxVp8Encoder::PopulateCodecSpecific(CodecSpecificInfo* codec_specific,
 
   int qp = 0;
   vpx_codec_control(&encoders_[encoder_idx], VP8E_GET_LAST_QUANTIZER_64, &qp);
-  bool is_keyframe = (pkt.data.frame.flags & VPX_FRAME_IS_KEY) != 0;
-  frame_buffer_controller_->OnEncodeDone(stream_idx, timestamp,
-                                         encoded_images_[encoder_idx].size(),
-                                         is_keyframe, qp, codec_specific);
-  if (is_keyframe && codec_specific->template_structure != absl::nullopt) {
-    // Number of resolutions must match number of spatial layers, VP8 structures
-    // expected to use single spatial layer. Templates must be ordered by
-    // spatial_id, so assumption there is exactly one spatial layer is same as
-    // assumption last template uses spatial_id = 0.
-    // This check catches potential scenario where template_structure is shared
-    // across multiple vp8 streams and they are distinguished using spatial_id.
-    // Assigning single resolution doesn't support such scenario, i.e. assumes
-    // vp8 simulcast is sent using multiple ssrcs.
-    RTC_DCHECK(!codec_specific->template_structure->templates.empty());
-    RTC_DCHECK_EQ(
-        codec_specific->template_structure->templates.back().spatial_id, 0);
-    codec_specific->template_structure->resolutions = {
-        RenderResolution(pkt.data.frame.width[0], pkt.data.frame.height[0])};
-  }
+  frame_buffer_controller_->OnEncodeDone(
+      stream_idx, timestamp, encoded_images_[encoder_idx].size(),
+      (pkt.data.frame.flags & VPX_FRAME_IS_KEY) != 0, qp, codec_specific);
 }
 
 int LibvpxVp8Encoder::GetEncodedPartitions(const VideoFrame& input_image,
@@ -1240,8 +1237,6 @@ void LibvpxVp8Encoder::MaybeUpdatePixelF
         << "Not all raw images had the right format!";
     return;
   }
-  RTC_LOG(INFO) << "Updating vp8 encoder pixel format to "
-                << (fmt == VPX_IMG_FMT_NV12 ? "NV12" : "I420");
   for (size_t i = 0; i < raw_images_.size(); ++i) {
     vpx_image_t& img = raw_images_[i];
     auto d_w = img.d_w;
@@ -1288,7 +1283,6 @@ void LibvpxVp8Encoder::PrepareI420Image(
 
 void LibvpxVp8Encoder::PrepareNV12Image(const NV12BufferInterface* frame) {
   RTC_DCHECK(!raw_images_.empty());
-  MaybeUpdatePixelFormat(VPX_IMG_FMT_NV12);
   // Image in vpx_image_t format.
   // Input image is const. VP8's raw image is not defined as const.
   raw_images_[0].planes[VPX_PLANE_Y] = const_cast<uint8_t*>(frame->DataY());
--- a/third_party/webrtc/modules/video_coding/codecs/vp9/libvpx_vp9_encoder.cc
+++ b/third_party/webrtc/modules/video_coding/codecs/vp9/libvpx_vp9_encoder.cc
@@ -150,39 +150,6 @@ std::unique_ptr<ScalableVideoController> CreateVp9ScalabilityStructure(
   return scalability_structure_controller;
 }
 
-vpx_svc_ref_frame_config_t Vp9References(
-    rtc::ArrayView<const ScalableVideoController::LayerFrameConfig> layers) {
-  vpx_svc_ref_frame_config_t ref_config = {};
-  for (const ScalableVideoController::LayerFrameConfig& layer_frame : layers) {
-    const auto& buffers = layer_frame.Buffers();
-    RTC_DCHECK_LE(buffers.size(), 3);
-    int sid = layer_frame.SpatialId();
-    if (!buffers.empty()) {
-      ref_config.lst_fb_idx[sid] = buffers[0].id;
-      ref_config.reference_last[sid] = buffers[0].referenced;
-      if (buffers[0].updated) {
-        ref_config.update_buffer_slot[sid] |= (1 << buffers[0].id);
-      }
-    }
-    if (buffers.size() > 1) {
-      ref_config.gld_fb_idx[sid] = buffers[1].id;
-      ref_config.reference_golden[sid] = buffers[1].referenced;
-      if (buffers[1].updated) {
-        ref_config.update_buffer_slot[sid] |= (1 << buffers[1].id);
-      }
-    }
-    if (buffers.size() > 2) {
-      ref_config.alt_fb_idx[sid] = buffers[2].id;
-      ref_config.reference_alt_ref[sid] = buffers[2].referenced;
-      if (buffers[2].updated) {
-        ref_config.update_buffer_slot[sid] |= (1 << buffers[2].id);
-      }
-    }
-  }
-  // TODO(bugs.webrtc.org/11999): Fill ref_config.duration
-  return ref_config;
-}
-
 }  // namespace
 
 void LibvpxVp9Encoder::EncoderOutputCodedPacketCallback(vpx_codec_cx_pkt* pkt,
@@ -388,15 +355,6 @@ bool LibvpxVp9Encoder::SetSvcRates(
     }
   }
 
-  if (higher_layers_enabled && !force_key_frame_) {
-    // Prohibit drop of all layers for the next frame, so newly enabled
-    // layer would have a valid spatial reference.
-    for (size_t i = 0; i < num_spatial_layers_; ++i) {
-      svc_drop_frame_.framedrop_thresh[i] = 0;
-    }
-    force_all_active_layers_ = true;
-  }
-
   if (svc_controller_) {
     VideoBitrateAllocation allocation;
     for (int sid = 0; sid < num_spatial_layers_; ++sid) {
@@ -743,8 +701,6 @@ int LibvpxVp9Encoder::InitAndSetControlSettings(const VideoCodec* inst) {
     for (int si = 0; si < num_spatial_layers_; ++si) {
       svc_params_.speed_per_layer[si] =
           performance_flags_by_spatial_index_[si].base_layer_speed;
-      svc_params_.loopfilter_ctrl[si] =
-          performance_flags_by_spatial_index_[si].deblock_mode;
     }
   }
 
@@ -754,7 +710,6 @@ int LibvpxVp9Encoder::InitAndSetControlSettings(const VideoCodec* inst) {
                          inst->VP9().adaptiveQpMode ? 3 : 0);
 
   libvpx_->codec_control(encoder_, VP9E_SET_FRAME_PARALLEL_DECODING, 0);
-  libvpx_->codec_control(encoder_, VP9E_SET_SVC_GF_TEMPORAL_REF, 0);
 
   if (is_svc_) {
     libvpx_->codec_control(encoder_, VP9E_SET_SVC, 1);
@@ -766,56 +721,6 @@ int LibvpxVp9Encoder::InitAndSetControlSettings(const VideoCodec* inst) {
         performance_flags_by_spatial_index_.rbegin()->base_layer_speed);
   }
 
-  if (num_spatial_layers_ > 1) {
-    switch (inter_layer_pred_) {
-      case InterLayerPredMode::kOn:
-        libvpx_->codec_control(encoder_, VP9E_SET_SVC_INTER_LAYER_PRED, 0);
-        break;
-      case InterLayerPredMode::kOff:
-        libvpx_->codec_control(encoder_, VP9E_SET_SVC_INTER_LAYER_PRED, 1);
-        break;
-      case InterLayerPredMode::kOnKeyPic:
-        libvpx_->codec_control(encoder_, VP9E_SET_SVC_INTER_LAYER_PRED, 2);
-        break;
-      default:
-        RTC_NOTREACHED();
-    }
-
-    memset(&svc_drop_frame_, 0, sizeof(svc_drop_frame_));
-    const bool reverse_constrained_drop_mode =
-        inter_layer_pred_ == InterLayerPredMode::kOn &&
-        codec_.mode == VideoCodecMode::kScreensharing &&
-        num_spatial_layers_ > 1;
-    if (reverse_constrained_drop_mode) {
-      // Screenshare dropping mode: drop a layer only together with all lower
-      // layers. This ensures that drops on lower layers won't reduce frame-rate
-      // for higher layers and reference structure is RTP-compatible.
-      svc_drop_frame_.framedrop_mode = CONSTRAINED_FROM_ABOVE_DROP;
-      svc_drop_frame_.max_consec_drop = 5;
-      for (size_t i = 0; i < num_spatial_layers_; ++i) {
-        svc_drop_frame_.framedrop_thresh[i] = config_->rc_dropframe_thresh;
-      }
-      // No buffering is needed because the highest layer is always present in
-      // all frames in CONSTRAINED_FROM_ABOVE drop mode.
-      layer_buffering_ = false;
-    } else {
-      // Configure encoder to drop entire superframe whenever it needs to drop
-      // a layer. This mode is preferred over per-layer dropping which causes
-      // quality flickering and is not compatible with RTP non-flexible mode.
-      svc_drop_frame_.framedrop_mode =
-          full_superframe_drop_ ? FULL_SUPERFRAME_DROP : CONSTRAINED_LAYER_DROP;
-      // Buffering is needed only for constrained layer drop, as it's not clear
-      // which frame is the last.
-      layer_buffering_ = !full_superframe_drop_;
-      svc_drop_frame_.max_consec_drop = std::numeric_limits<int>::max();
-      for (size_t i = 0; i < num_spatial_layers_; ++i) {
-        svc_drop_frame_.framedrop_thresh[i] = config_->rc_dropframe_thresh;
-      }
-    }
-    libvpx_->codec_control(encoder_, VP9E_SET_SVC_FRAME_DROP_LAYER,
-                           &svc_drop_frame_);
-  }
-
   // Register callback for getting each spatial layer.
   vpx_codec_priv_output_cx_pkt_cb_pair_t cbp = {
       LibvpxVp9Encoder::EncoderOutputCodedPacketCallback,
@@ -959,52 +864,10 @@ int LibvpxVp9Encoder::Encode(const VideoFrame& input_image,
     }
   }
 
-  // Need to set temporal layer id on ALL layers, even disabled ones.
-  // Otherwise libvpx might produce frames on a disabled layer:
-  // http://crbug.com/1051476
-  for (int sl_idx = 0; sl_idx < num_spatial_layers_; ++sl_idx) {
-    layer_id.temporal_layer_id_per_spatial[sl_idx] = layer_id.temporal_layer_id;
-  }
-
   if (layer_id.spatial_layer_id < first_active_layer_) {
     layer_id.spatial_layer_id = first_active_layer_;
   }
 
-  if (svc_controller_) {
-    layer_id.spatial_layer_id = layer_frames_.front().SpatialId();
-    layer_id.temporal_layer_id = layer_frames_.front().TemporalId();
-    for (const auto& layer : layer_frames_) {
-      layer_id.temporal_layer_id_per_spatial[layer.SpatialId()] =
-          layer.TemporalId();
-    }
-  }
-
-  if (is_svc_ && performance_flags_.use_per_layer_speed) {
-    // Update speed settings that might depend on temporal index.
-    bool speed_updated = false;
-    for (int sl_idx = 0; sl_idx < num_spatial_layers_; ++sl_idx) {
-      const int target_speed =
-          layer_id.temporal_layer_id_per_spatial[sl_idx] == 0
-              ? performance_flags_by_spatial_index_[sl_idx].base_layer_speed
-              : performance_flags_by_spatial_index_[sl_idx].high_layer_speed;
-      if (svc_params_.speed_per_layer[sl_idx] != target_speed) {
-        svc_params_.speed_per_layer[sl_idx] = target_speed;
-        speed_updated = true;
-      }
-    }
-    if (speed_updated) {
-      libvpx_->codec_control(encoder_, VP9E_SET_SVC_PARAMETERS, &svc_params_);
-    }
-  }
-
-  libvpx_->codec_control(encoder_, VP9E_SET_SVC_LAYER_ID, &layer_id);
-
-  if (num_spatial_layers_ > 1) {
-    // Update frame dropping settings as they may change on per-frame basis.
-    libvpx_->codec_control(encoder_, VP9E_SET_SVC_FRAME_DROP_LAYER,
-                           &svc_drop_frame_);
-  }
-
   if (config_changed_) {
     if (libvpx_->codec_enc_config_set(encoder_, config_)) {
       return WEBRTC_VIDEO_CODEC_ERROR;
@@ -1046,19 +909,7 @@ int LibvpxVp9Encoder::Encode(const VideoFrame& input_image,
   rtc::scoped_refptr<const I010BufferInterface> i010_copy;
   switch (profile_) {
     case VP9Profile::kProfile0: {
-      if (input_image.video_frame_buffer()->type() ==
-          VideoFrameBuffer::Type::kNV12) {
-        const NV12BufferInterface* nv12_buffer =
-            input_image.video_frame_buffer()->GetNV12();
-        video_frame_buffer = nv12_buffer;
-        MaybeRewrapRawWithFormat(VPX_IMG_FMT_NV12);
-        raw_->planes[VPX_PLANE_Y] = const_cast<uint8_t*>(nv12_buffer->DataY());
-        raw_->planes[VPX_PLANE_U] = const_cast<uint8_t*>(nv12_buffer->DataUV());
-        raw_->planes[VPX_PLANE_V] = raw_->planes[VPX_PLANE_U] + 1;
-        raw_->stride[VPX_PLANE_Y] = nv12_buffer->StrideY();
-        raw_->stride[VPX_PLANE_U] = nv12_buffer->StrideUV();
-        raw_->stride[VPX_PLANE_V] = nv12_buffer->StrideUV();
-      } else {
+      {
         rtc::scoped_refptr<I420BufferInterface> i420_buffer =
             input_image.video_frame_buffer()->ToI420();
         video_frame_buffer = i420_buffer;
@@ -1110,26 +961,6 @@ int LibvpxVp9Encoder::Encode(const VideoFrame& input_image,
     flags = VPX_EFLAG_FORCE_KF;
   }
 
-  if (svc_controller_) {
-    vpx_svc_ref_frame_config_t ref_config = Vp9References(layer_frames_);
-    libvpx_->codec_control(encoder_, VP9E_SET_SVC_REF_FRAME_CONFIG,
-                           &ref_config);
-  } else if (external_ref_control_) {
-    vpx_svc_ref_frame_config_t ref_config =
-        SetReferences(force_key_frame_, layer_id.spatial_layer_id);
-
-    if (VideoCodecMode::kScreensharing == codec_.mode) {
-      for (uint8_t sl_idx = 0; sl_idx < num_active_spatial_layers_; ++sl_idx) {
-        ref_config.duration[sl_idx] = static_cast<int64_t>(
-            90000 / (std::min(static_cast<float>(codec_.maxFramerate),
-                              framerate_controller_[sl_idx].GetTargetRate())));
-      }
-    }
-
-    libvpx_->codec_control(encoder_, VP9E_SET_SVC_REF_FRAME_CONFIG,
-                           &ref_config);
-  }
-
   first_frame_in_picture_ = true;
 
   // TODO(ssilkin): Frame duration should be specified per spatial layer
@@ -1236,11 +1067,7 @@ void LibvpxVp9Encoder::PopulateCodecSpecific(CodecSpecificInfo* codec_specific,
   vp9_info->first_active_layer = first_active_layer_;
 
   vp9_info->num_ref_pics = 0;
-  FillReferenceIndices(pkt, pics_since_key_, vp9_info->inter_layer_predicted,
-                       vp9_info);
-  if (vp9_info->flexible_mode) {
-    vp9_info->gof_idx = kNoGofIdx;
-  } else {
+  {
     vp9_info->gof_idx =
         static_cast<uint8_t>(pics_since_key_ % gof_.num_frames_in_gof);
     vp9_info->temporal_up_switch = gof_.temporal_up_switch[vp9_info->gof_idx];
@@ -1308,261 +1135,6 @@ void LibvpxVp9Encoder::PopulateCodecSpecific(CodecSpecificInfo* codec_specific,
   }
 }
 
-void LibvpxVp9Encoder::FillReferenceIndices(const vpx_codec_cx_pkt& pkt,
-                                            const size_t pic_num,
-                                            const bool inter_layer_predicted,
-                                            CodecSpecificInfoVP9* vp9_info) {
-  vpx_svc_layer_id_t layer_id = {0};
-  libvpx_->codec_control(encoder_, VP9E_GET_SVC_LAYER_ID, &layer_id);
-
-  const bool is_key_frame =
-      (pkt.data.frame.flags & VPX_FRAME_IS_KEY) ? true : false;
-
-  std::vector<RefFrameBuffer> ref_buf_list;
-
-  if (is_svc_) {
-    vpx_svc_ref_frame_config_t enc_layer_conf = {{0}};
-    libvpx_->codec_control(encoder_, VP9E_GET_SVC_REF_FRAME_CONFIG,
-                           &enc_layer_conf);
-    int ref_buf_flags = 0;
-
-    if (enc_layer_conf.reference_last[layer_id.spatial_layer_id]) {
-      const size_t fb_idx =
-          enc_layer_conf.lst_fb_idx[layer_id.spatial_layer_id];
-      RTC_DCHECK(ref_buf_.find(fb_idx) != ref_buf_.end());
-      if (std::find(ref_buf_list.begin(), ref_buf_list.end(),
-                    ref_buf_.at(fb_idx)) == ref_buf_list.end()) {
-        ref_buf_list.push_back(ref_buf_.at(fb_idx));
-        ref_buf_flags |= 1 << fb_idx;
-      }
-    }
-
-    if (enc_layer_conf.reference_alt_ref[layer_id.spatial_layer_id]) {
-      const size_t fb_idx =
-          enc_layer_conf.alt_fb_idx[layer_id.spatial_layer_id];
-      RTC_DCHECK(ref_buf_.find(fb_idx) != ref_buf_.end());
-      if (std::find(ref_buf_list.begin(), ref_buf_list.end(),
-                    ref_buf_.at(fb_idx)) == ref_buf_list.end()) {
-        ref_buf_list.push_back(ref_buf_.at(fb_idx));
-        ref_buf_flags |= 1 << fb_idx;
-      }
-    }
-
-    if (enc_layer_conf.reference_golden[layer_id.spatial_layer_id]) {
-      const size_t fb_idx =
-          enc_layer_conf.gld_fb_idx[layer_id.spatial_layer_id];
-      RTC_DCHECK(ref_buf_.find(fb_idx) != ref_buf_.end());
-      if (std::find(ref_buf_list.begin(), ref_buf_list.end(),
-                    ref_buf_.at(fb_idx)) == ref_buf_list.end()) {
-        ref_buf_list.push_back(ref_buf_.at(fb_idx));
-        ref_buf_flags |= 1 << fb_idx;
-      }
-    }
-
-    RTC_LOG(LS_VERBOSE) << "Frame " << pic_num << " sl "
-                        << layer_id.spatial_layer_id << " tl "
-                        << layer_id.temporal_layer_id << " refered buffers "
-                        << (ref_buf_flags & (1 << 0) ? 1 : 0)
-                        << (ref_buf_flags & (1 << 1) ? 1 : 0)
-                        << (ref_buf_flags & (1 << 2) ? 1 : 0)
-                        << (ref_buf_flags & (1 << 3) ? 1 : 0)
-                        << (ref_buf_flags & (1 << 4) ? 1 : 0)
-                        << (ref_buf_flags & (1 << 5) ? 1 : 0)
-                        << (ref_buf_flags & (1 << 6) ? 1 : 0)
-                        << (ref_buf_flags & (1 << 7) ? 1 : 0);
-
-  } else if (!is_key_frame) {
-    RTC_DCHECK_EQ(num_spatial_layers_, 1);
-    RTC_DCHECK_EQ(num_temporal_layers_, 1);
-    // In non-SVC mode encoder doesn't provide reference list. Assume each frame
-    // refers previous one, which is stored in buffer 0.
-    ref_buf_list.push_back(ref_buf_.at(0));
-  }
-
-  size_t max_ref_temporal_layer_id = 0;
-
-  std::vector<size_t> ref_pid_list;
-
-  vp9_info->num_ref_pics = 0;
-  for (const RefFrameBuffer& ref_buf : ref_buf_list) {
-    RTC_DCHECK_LE(ref_buf.pic_num, pic_num);
-    if (ref_buf.pic_num < pic_num) {
-      if (inter_layer_pred_ != InterLayerPredMode::kOn) {
-        // RTP spec limits temporal prediction to the same spatial layer.
-        // It is safe to ignore this requirement if inter-layer prediction is
-        // enabled for all frames when all base frames are relayed to receiver.
-        RTC_DCHECK_EQ(ref_buf.spatial_layer_id, layer_id.spatial_layer_id);
-      } else {
-        RTC_DCHECK_LE(ref_buf.spatial_layer_id, layer_id.spatial_layer_id);
-      }
-      RTC_DCHECK_LE(ref_buf.temporal_layer_id, layer_id.temporal_layer_id);
-
-      // Encoder may reference several spatial layers on the same previous
-      // frame in case if some spatial layers are skipped on the current frame.
-      // We shouldn't put duplicate references as it may break some old
-      // clients and isn't RTP compatible.
-      if (std::find(ref_pid_list.begin(), ref_pid_list.end(),
-                    ref_buf.pic_num) != ref_pid_list.end()) {
-        continue;
-      }
-      ref_pid_list.push_back(ref_buf.pic_num);
-
-      const size_t p_diff = pic_num - ref_buf.pic_num;
-      RTC_DCHECK_LE(p_diff, 127UL);
-
-      vp9_info->p_diff[vp9_info->num_ref_pics] = static_cast<uint8_t>(p_diff);
-      ++vp9_info->num_ref_pics;
-
-      max_ref_temporal_layer_id =
-          std::max(max_ref_temporal_layer_id, ref_buf.temporal_layer_id);
-    } else {
-      RTC_DCHECK(inter_layer_predicted);
-      // RTP spec only allows to use previous spatial layer for inter-layer
-      // prediction.
-      RTC_DCHECK_EQ(ref_buf.spatial_layer_id + 1, layer_id.spatial_layer_id);
-    }
-  }
-
-  vp9_info->temporal_up_switch =
-      (max_ref_temporal_layer_id <
-       static_cast<size_t>(layer_id.temporal_layer_id));
-}
-
-void LibvpxVp9Encoder::UpdateReferenceBuffers(const vpx_codec_cx_pkt& pkt,
-                                              const size_t pic_num) {
-  vpx_svc_layer_id_t layer_id = {0};
-  libvpx_->codec_control(encoder_, VP9E_GET_SVC_LAYER_ID, &layer_id);
-
-  RefFrameBuffer frame_buf(pic_num, layer_id.spatial_layer_id,
-                           layer_id.temporal_layer_id);
-
-  if (is_svc_) {
-    vpx_svc_ref_frame_config_t enc_layer_conf = {{0}};
-    libvpx_->codec_control(encoder_, VP9E_GET_SVC_REF_FRAME_CONFIG,
-                           &enc_layer_conf);
-    const int update_buffer_slot =
-        enc_layer_conf.update_buffer_slot[layer_id.spatial_layer_id];
-
-    for (size_t i = 0; i < kNumVp9Buffers; ++i) {
-      if (update_buffer_slot & (1 << i)) {
-        ref_buf_[i] = frame_buf;
-      }
-    }
-
-    RTC_LOG(LS_VERBOSE) << "Frame " << pic_num << " sl "
-                        << layer_id.spatial_layer_id << " tl "
-                        << layer_id.temporal_layer_id << " updated buffers "
-                        << (update_buffer_slot & (1 << 0) ? 1 : 0)
-                        << (update_buffer_slot & (1 << 1) ? 1 : 0)
-                        << (update_buffer_slot & (1 << 2) ? 1 : 0)
-                        << (update_buffer_slot & (1 << 3) ? 1 : 0)
-                        << (update_buffer_slot & (1 << 4) ? 1 : 0)
-                        << (update_buffer_slot & (1 << 5) ? 1 : 0)
-                        << (update_buffer_slot & (1 << 6) ? 1 : 0)
-                        << (update_buffer_slot & (1 << 7) ? 1 : 0);
-  } else {
-    RTC_DCHECK_EQ(num_spatial_layers_, 1);
-    RTC_DCHECK_EQ(num_temporal_layers_, 1);
-    // In non-svc mode encoder doesn't provide reference list. Assume each frame
-    // is reference and stored in buffer 0.
-    ref_buf_[0] = frame_buf;
-  }
-}
-
-vpx_svc_ref_frame_config_t LibvpxVp9Encoder::SetReferences(
-    bool is_key_pic,
-    size_t first_active_spatial_layer_id) {
-  // kRefBufIdx, kUpdBufIdx need to be updated to support longer GOFs.
-  RTC_DCHECK_LE(gof_.num_frames_in_gof, 4);
-
-  vpx_svc_ref_frame_config_t ref_config;
-  memset(&ref_config, 0, sizeof(ref_config));
-
-  const size_t num_temporal_refs = std::max(1, num_temporal_layers_ - 1);
-  const bool is_inter_layer_pred_allowed =
-      inter_layer_pred_ == InterLayerPredMode::kOn ||
-      (inter_layer_pred_ == InterLayerPredMode::kOnKeyPic && is_key_pic);
-  absl::optional<int> last_updated_buf_idx;
-
-  // Put temporal reference to LAST and spatial reference to GOLDEN. Update
-  // frame buffer (i.e. store encoded frame) if current frame is a temporal
-  // reference (i.e. it belongs to a low temporal layer) or it is a spatial
-  // reference. In later case, always store spatial reference in the last
-  // reference frame buffer.
-  // For the case of 3 temporal and 3 spatial layers we need 6 frame buffers
-  // for temporal references plus 1 buffer for spatial reference. 7 buffers
-  // in total.
-
-  for (size_t sl_idx = first_active_spatial_layer_id;
-       sl_idx < num_active_spatial_layers_; ++sl_idx) {
-    const size_t curr_pic_num = is_key_pic ? 0 : pics_since_key_ + 1;
-    const size_t gof_idx = curr_pic_num % gof_.num_frames_in_gof;
-
-    if (!is_key_pic) {
-      // Set up temporal reference.
-      const int buf_idx = sl_idx * num_temporal_refs + kRefBufIdx[gof_idx];
-
-      // Last reference frame buffer is reserved for spatial reference. It is
-      // not supposed to be used for temporal prediction.
-      RTC_DCHECK_LT(buf_idx, kNumVp9Buffers - 1);
-
-      const int pid_diff = curr_pic_num - ref_buf_[buf_idx].pic_num;
-      // Incorrect spatial layer may be in the buffer due to a key-frame.
-      const bool same_spatial_layer =
-          ref_buf_[buf_idx].spatial_layer_id == sl_idx;
-      bool correct_pid = false;
-      if (is_flexible_mode_) {
-        correct_pid = pid_diff > 0 && pid_diff < kMaxAllowedPidDiff;
-      } else {
-        // Below code assumes single temporal referecence.
-        RTC_DCHECK_EQ(gof_.num_ref_pics[gof_idx], 1);
-        correct_pid = pid_diff == gof_.pid_diff[gof_idx][0];
-      }
-
-      if (same_spatial_layer && correct_pid) {
-        ref_config.lst_fb_idx[sl_idx] = buf_idx;
-        ref_config.reference_last[sl_idx] = 1;
-      } else {
-        // This reference doesn't match with one specified by GOF. This can
-        // only happen if spatial layer is enabled dynamically without key
-        // frame. Spatial prediction is supposed to be enabled in this case.
-        RTC_DCHECK(is_inter_layer_pred_allowed &&
-                   sl_idx > first_active_spatial_layer_id);
-      }
-    }
-
-    if (is_inter_layer_pred_allowed && sl_idx > first_active_spatial_layer_id) {
-      // Set up spatial reference.
-      RTC_DCHECK(last_updated_buf_idx);
-      ref_config.gld_fb_idx[sl_idx] = *last_updated_buf_idx;
-      ref_config.reference_golden[sl_idx] = 1;
-    } else {
-      RTC_DCHECK(ref_config.reference_last[sl_idx] != 0 ||
-                 sl_idx == first_active_spatial_layer_id ||
-                 inter_layer_pred_ == InterLayerPredMode::kOff);
-    }
-
-    last_updated_buf_idx.reset();
-
-    if (gof_.temporal_idx[gof_idx] < num_temporal_layers_ - 1 ||
-        num_temporal_layers_ == 1) {
-      last_updated_buf_idx = sl_idx * num_temporal_refs + kUpdBufIdx[gof_idx];
-
-      // Ensure last frame buffer is not used for temporal prediction (it is
-      // reserved for spatial reference).
-      RTC_DCHECK_LT(*last_updated_buf_idx, kNumVp9Buffers - 1);
-    } else if (is_inter_layer_pred_allowed) {
-      last_updated_buf_idx = kNumVp9Buffers - 1;
-    }
-
-    if (last_updated_buf_idx) {
-      ref_config.update_buffer_slot[sl_idx] = 1 << *last_updated_buf_idx;
-    }
-  }
-
-  return ref_config;
-}
-
 int LibvpxVp9Encoder::GetEncodedLayerFrame(const vpx_codec_cx_pkt* pkt) {
   RTC_DCHECK_EQ(pkt->kind, VPX_CODEC_CX_FRAME_PKT);
 
@@ -1603,14 +1175,10 @@ int LibvpxVp9Encoder::GetEncodedLayerFrame(const vpx_codec_cx_pkt* pkt) {
                         input_image_->timestamp());
   encoded_image_.SetSpatialIndex(spatial_index);
 
-  UpdateReferenceBuffers(*pkt, pics_since_key_);
-
   TRACE_COUNTER1("webrtc", "EncodedFrameSize", encoded_image_.size());
   encoded_image_.SetTimestamp(input_image_->timestamp());
-  encoded_image_._encodedHeight =
-      pkt->data.frame.height[layer_id.spatial_layer_id];
-  encoded_image_._encodedWidth =
-      pkt->data.frame.width[layer_id.spatial_layer_id];
+  encoded_image_._encodedHeight = raw_->d_h;
+  encoded_image_._encodedWidth = raw_->d_w;
   int qp = -1;
   libvpx_->codec_control(encoder_, VP8E_GET_LAST_QUANTIZER, &qp);
   encoded_image_.qp_ = qp;
@@ -1626,14 +1194,6 @@ int LibvpxVp9Encoder::GetEncodedLayerFrame(const vpx_codec_cx_pkt* pkt) {
 
 void LibvpxVp9Encoder::DeliverBufferedFrame(bool end_of_picture) {
   if (encoded_image_.size() > 0) {
-    if (num_spatial_layers_ > 1) {
-      // Restore frame dropping settings, as dropping may be temporary forbidden
-      // due to dynamically enabled layers.
-      for (size_t i = 0; i < num_spatial_layers_; ++i) {
-        svc_drop_frame_.framedrop_thresh[i] = config_->rc_dropframe_thresh;
-      }
-    }
-
     codec_specific_.end_of_picture = end_of_picture;
 
     encoded_complete_callback_->OnEncodedImage(encoded_image_,
@@ -1871,8 +1431,6 @@ void LibvpxVp9Encoder::MaybeRewrapRawWithFormat(const vpx_img_fmt fmt) {
     raw_ = libvpx_->img_wrap(nullptr, fmt, codec_.width, codec_.height, 1,
                              nullptr);
   } else if (raw_->fmt != fmt) {
-    RTC_LOG(INFO) << "Switching VP9 encoder pixel format to "
-                  << (fmt == VPX_IMG_FMT_NV12 ? "NV12" : "I420");
     libvpx_->img_free(raw_);
     raw_ = libvpx_->img_wrap(nullptr, fmt, codec_.width, codec_.height, 1,
                              nullptr);
--- a/third_party/webrtc/modules/video_coding/codecs/vp9/libvpx_vp9_encoder.h
+++ b/third_party/webrtc/modules/video_coding/codecs/vp9/libvpx_vp9_encoder.h
@@ -133,7 +133,6 @@ class VP9EncoderImpl : public VP9Encoder
   const bool trusted_rate_controller_;
   bool layer_buffering_;
   const bool full_superframe_drop_;
-  vpx_svc_frame_drop_t svc_drop_frame_;
   bool first_frame_in_picture_;
   VideoBitrateAllocation current_bitrate_allocation_;
   bool ss_info_needed_;
--- a/third_party/webrtc/modules/video_coding/codecs/vp9/libvpx_vp9_decoder.cc
+++ b/third_party/webrtc/modules/video_coding/codecs/vp9/libvpx_vp9_decoder.cc
@@ -185,14 +185,6 @@ int LibvpxVp9Decoder::InitDecode(const VideoCodec* inst, int number_of_cores) {
     }
   }
 
-  vpx_codec_err_t status =
-      vpx_codec_control(decoder_, VP9D_SET_LOOP_FILTER_OPT, 1);
-  if (status != VPX_CODEC_OK) {
-    RTC_LOG(LS_ERROR) << "Failed to enable VP9D_SET_LOOP_FILTER_OPT. "
-                      << vpx_codec_error(decoder_);
-    return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
-  }
-
   return WEBRTC_VIDEO_CODEC_OK;
 }
 

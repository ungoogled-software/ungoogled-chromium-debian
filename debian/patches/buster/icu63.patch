description: maintain compatibility with icu 6.3
author: Michael Gilbert <mgilbert@debian.org>

--- b/chrome/browser/web_applications/BUILD.gn
+++ a/chrome/browser/web_applications/BUILD.gn
@@ -338,7 +338,6 @@
     ":web_applications_unit_tests",
     "//chrome/browser/web_applications/components:unit_tests",
     "//chrome/browser/web_applications/extensions:unit_tests",
-    "//chrome/browser/web_applications/preinstalled_web_apps:unit_tests",
   ]
 }
 
--- b/chrome/browser/web_applications/preinstalled_web_apps/BUILD.gn
+++ a/chrome/browser/web_applications/preinstalled_web_apps/BUILD.gn
@@ -17,7 +17,6 @@ source_set("preinstalled_web_apps") {
     "//base",
     "//build:branding_buildflags",
     "//build:chromeos_buildflags",
-    "//chrome/browser:browser_process",
     "//chrome/browser/web_applications/components",
     "//chrome/common:non_code_constants",
     "//skia",
@@ -40,16 +39,3 @@
     deps += [ "//chrome/browser/resources:preinstalled_web_apps_resources" ]
   }
 }
-
-source_set("unit_tests") {
-  testonly = true
-
-  sources = [ "preinstalled_web_app_utils_unittest.cc" ]
-
-  deps = [
-    "//chrome/browser:browser_process",
-    "//chrome/browser/web_applications/preinstalled_web_apps",
-    "//skia",
-    "//testing/gtest",
-  ]
-}
--- b/chrome/browser/web_applications/preinstalled_web_apps/google_docs.cc
+++ a/chrome/browser/web_applications/preinstalled_web_apps/google_docs.cc
@@ -13,90 +13,6 @@
 
 namespace web_app {
 
-namespace {
-
-// clang-format off
-constexpr Translation kNameTranslations[] = {
-    {"af", u8"Dokumente"},
-    {"am", u8"ሰነዶች"},
-    {"ar", u8"مستندات"},
-    {"hy", u8"Փաստաթղթեր"},
-    {"az", u8"Sənəd"},
-    {"eu", u8"Dokumentuak"},
-    {"be", u8"Дакументы"},
-    {"bn", u8"Docs"},
-    {"bg", u8"Документи"},
-    {"my", u8"Docs"},
-    {"ca", u8"Documents"},
-    {"zh-HK", u8"Google 文件"},
-    {"zh-CN", u8"Google 文档"},
-    {"zh-TW", u8"文件"},
-    {"hr", u8"Dokumenti"},
-    {"cs", u8"Dokumenty"},
-    {"da", u8"Docs"},
-    {"nl", u8"Documenten"},
-    {"en-AU", u8"Docs"},
-    {"en-GB", u8"Docs"},
-    {"et", u8"Dokumendid"},
-    {"fil", u8"Docs"},
-    {"fi", u8"Docs"},
-    {"fr", u8"Docs"},
-    {"fr-CA", u8"Documents"},
-    {"gl", u8"Documentos"},
-    {"ka", u8"Docs"},
-    {"de", u8"Dokumente"},
-    {"el", u8"Έγγραφα"},
-    {"gu", u8"Docs"},
-    {"iw", u8"Docs"},
-    {"hi", u8"Docs"},
-    {"hu", u8"Dokumentumok"},
-    {"is", u8"Skjöl"},
-    {"id", u8"Dokumen"},
-    {"it", u8"Documenti"},
-    {"ja", u8"ドキュメント"},
-    {"kn", u8"Docs"},
-    {"kk", u8"Құжаттар"},
-    {"km", u8"ឯកសារ"},
-    {"ko", u8"문서"},
-    {"lo", u8"ເອກະສານ"},
-    {"lv", u8"Dokumenti"},
-    {"lt", u8"Dokumentai"},
-    {"ms", u8"Dokumen"},
-    {"ml", u8"Docs"},
-    {"mr", u8"Docs"},
-    {"mn", u8"Docs"},
-    {"ne", u8"कागजात"},
-    {"no", u8"Dokumenter"},
-    {"or", u8"Docs"},
-    {"fa", u8"سندنگار"},
-    {"pl", u8"Dokumenty"},
-    {"pt-BR", u8"Textos"},
-    {"pt-PT", u8"Docs"},
-    {"pa", u8"Docs"},
-    {"ro", u8"Documente"},
-    {"ru", u8"Документы"},
-    {"sr", u8"Документи"},
-    {"si", u8"Docs"},
-    {"sk", u8"Dokumenty"},
-    {"sl", u8"Dokumenti"},
-    {"es", u8"Documentos"},
-    {"es-419", u8"Documentos"},
-    {"sw", u8"Hati za Google"},
-    {"sv", u8"Dokument"},
-    {"ta", u8"Docs"},
-    {"te", u8"Docs"},
-    {"th", u8"เอกสาร"},
-    {"tr", u8"Dokümanlar"},
-    {"uk", u8"Документи"},
-    {"ur", u8"Docs"},
-    {"vi", u8"Tài liệu"},
-    {"cy", u8"Docs"},
-    {"zu", u8"Amadokhumenti"},
-};
-// clang-format on
-
-}  // namespace
-
 ExternalInstallOptions GetConfigForGoogleDocs() {
   ExternalInstallOptions options(
       /*install_url=*/GURL(
@@ -111,8 +27,7 @@
   options.only_use_app_info_factory = true;
   options.app_info_factory = base::BindRepeating([]() {
     auto info = std::make_unique<WebApplicationInfo>();
+    info->title = base::UTF8ToUTF16("Docs");
-    info->title =
-        base::UTF8ToUTF16(GetTranslatedName("Docs", kNameTranslations));
     info->start_url =
         GURL("https://docs.google.com/document/?usp=installed_webapp");
     info->scope = GURL("https://docs.google.com/document/");
--- b/chrome/browser/web_applications/preinstalled_web_apps/google_drive.cc
+++ a/chrome/browser/web_applications/preinstalled_web_apps/google_drive.cc
@@ -13,93 +13,6 @@
 
 namespace web_app {
 
-namespace {
-
-// clang-format off
-constexpr Translation kNameTranslations[] = {
-    {"af", u8"Google Drive"},
-    {"sq", u8"Disku i Google"},
-    {"am", u8"Google Drive"},
-    {"ar", u8"Google Drive"},
-    {"hy", u8"Google Drive"},
-    {"az", u8"Google Disk"},
-    {"eu", u8"Google Drive"},
-    {"be", u8"Google Дыск"},
-    {"bn", u8"Google Drive"},
-    {"bs", u8"Google Disk"},
-    {"bg", u8"Google Диск"},
-    {"my", u8"Google Drive"},
-    {"ca", u8"Google Drive"},
-    {"zh-HK", u8"Google 雲端硬碟"},
-    {"zh-CN", u8"Google 云端硬盘"},
-    {"zh-TW", u8"Google 雲端硬碟"},
-    {"hr", u8"Google disk"},
-    {"cs", u8"Disk Google"},
-    {"da", u8"Google Drev"},
-    {"nl", u8"Google Drive"},
-    {"en-GB", u8"Google Drive"},
-    {"et", u8"Google Drive"},
-    {"fil", u8"Google Drive"},
-    {"fi", u8"Google Drive"},
-    {"fr-CA", u8"Google Disque"},
-    {"fr", u8"Google Drive"},
-    {"gl", u8"Google Drive"},
-    {"ka", u8"Google Drive"},
-    {"de", u8"Google Drive"},
-    {"el", u8"Google Drive"},
-    {"gu", u8"Google Drive"},
-    {"iw", u8"Google Drive"},
-    {"hi", u8"Google Drive"},
-    {"hu", u8"Google Drive"},
-    {"is", u8"Google Drive"},
-    {"id", u8"Google Drive"},
-    {"it", u8"Google Drive"},
-    {"ja", u8"Google ドライブ"},
-    {"kn", u8"Google Drive"},
-    {"kk", u8"Google Drive"},
-    {"km", u8"Google ថាស"},
-    {"ko", u8"Google 드라이브"},
-    {"ky", u8"Google Drive"},
-    {"lo", u8"Google Drive"},
-    {"lv", u8"Google disks"},
-    {"lt", u8"„Google“ diskas"},
-    {"ms", u8"Google Drive"},
-    {"ml", u8"Google Drive"},
-    {"mr", u8"Google Drive"},
-    {"mn", u8"Google Драйв"},
-    {"ne", u8"Google Drive"},
-    {"no", u8"Google Disk"},
-    {"fa", u8"Google Drive"},
-    {"pl", u8"Dysk Google"},
-    {"pt-BR", u8"Google Drive"},
-    {"pt-PT", u8"Google Drive"},
-    {"pa", u8"Google Drive"},
-    {"ro", u8"Google Drive"},
-    {"ru", u8"Google Диск"},
-    {"sr", u8"Google диск"},
-    {"si", u8"Google Drive"},
-    {"sk", u8"Disk Google"},
-    {"sl", u8"Google Drive"},
-    {"es-419", u8"Google Drive"},
-    {"es", u8"Google Drive"},
-    {"sw", u8"Hifadhi ya Google"},
-    {"sv", u8"Google Drive"},
-    {"ta", u8"Google Drive"},
-    {"te", u8"Google Drive"},
-    {"th", u8"Google ไดรฟ์"},
-    {"tr", u8"Google Drive"},
-    {"uk", u8"Google Диск"},
-    {"ur", u8"Google Drive"},
-    {"uz", u8"Google Drive"},
-    {"vi", u8"Google Drive"},
-    {"cy", u8"Google Drive"},
-    {"zu", u8"Google Drayivu"},
-    {"zu", u8"Drayivu"},
-};
-// clang-format on
-
-}  // namespace
-
 ExternalInstallOptions GetConfigForGoogleDrive() {
   ExternalInstallOptions options(
       /*install_url=*/GURL(
@@ -116,8 +29,7 @@ ExternalInstallOptions GetConfigForGoogleDrive() {
   options.only_use_app_info_factory = true;
   options.app_info_factory = base::BindRepeating([]() {
     auto info = std::make_unique<WebApplicationInfo>();
-    info->title =
-        base::UTF8ToUTF16(GetTranslatedName("Google Drive", kNameTranslations));
+    info->title = base::UTF8ToUTF16("Google Drive");
     info->start_url = GURL("https://drive.google.com/?lfhs=2");
     info->scope = GURL("https://drive.google.com/");
     info->display_mode = DisplayMode::kStandalone;
--- b/chrome/browser/web_applications/preinstalled_web_apps/google_sheets.cc
+++ a/chrome/browser/web_applications/preinstalled_web_apps/google_sheets.cc
@@ -13,88 +13,6 @@
 
 namespace web_app {
 
-namespace {
-
-// clang-format off
-constexpr Translation kNameTranslations[] = {
-    {"af", u8"Blaaie"},
-    {"am", u8"ሉሆች"},
-    {"ar", u8"جداول البيانات"},
-    {"hy", u8"Աղյուսակներ"},
-    {"az", u8"Cədvəl"},
-    {"eu", u8"Kalkulu-orriak"},
-    {"be", u8"Табліцы"},
-    {"bn", u8"Sheets"},
-    {"bg", u8"Таблици"},
-    {"my", u8"စာမျက်နှာများ"},
-    {"ca", u8"Fulls de càlcul"},
-    {"zh-HK", u8"試算表"},
-    {"zh-CN", u8"表格"},
-    {"zh-TW", u8"試算表"},
-    {"hr", u8"Listovi"},
-    {"cs", u8"Tabulky"},
-    {"da", u8"Regneark"},
-    {"nl", u8"Spreadsheets"},
-    {"en-GB", u8"Sheets"},
-    {"et", u8"Lehed"},
-    {"fil", u8"Mga Sheet"},
-    {"fi", u8"Sheets"},
-    {"fr", u8"Feuilles de calcul"},
-    {"fr-CA", u8"Feuilles de calcul"},
-    {"gl", u8"Follas de cálculo"},
-    {"ka", u8"Sheets"},
-    {"de", u8"Tabellen"},
-    {"el", u8"Υπολογιστικά φύλλα"},
-    {"gu", u8"Sheets"},
-    {"iw", u8"Sheets"},
-    {"hi", u8"Sheets"},
-    {"hu", u8"Táblázatok"},
-    {"is", u8"Töflureiknar"},
-    {"id", u8"Spreadsheet"},
-    {"it", u8"Fogli"},
-    {"ja", u8"スプレッドシート"},
-    {"kn", u8"Sheets"},
-    {"kk", u8"Sheets"},
-    {"km", u8"បញ្ជី"},
-    {"ko", u8"스프레드시트"},
-    {"lo", u8"​ຊີດ"},
-    {"lv", u8"Izklājlapas"},
-    {"lt", u8"Skaičiuoklės"},
-    {"ms", u8"Helaian"},
-    {"ml", u8"Sheets"},
-    {"mr", u8"Sheets"},
-    {"mn", u8"Хүснэгт"},
-    {"ne", u8"पाना"},
-    {"no", u8"Regneark"},
-    {"fa", u8"کاربرگ‌نگار"},
-    {"pl", u8"Arkusze"},
-    {"pt-BR", u8"Planilhas"},
-    {"pt-PT", u8"Sheets"},
-    {"pa", u8"Sheets"},
-    {"ro", u8"Foi de calcul"},
-    {"ru", u8"Таблица"},
-    {"sr", u8"Табеле"},
-    {"si", u8"Sheets"},
-    {"sk", u8"Tabuľky"},
-    {"sl", u8"Preglednice"},
-    {"es", u8"Hojas de cálculo"},
-    {"es-419", u8"Hojas de cálculo"},
-    {"sw", u8"Majedwali"},
-    {"sv", u8"Kalkylark"},
-    {"ta", u8"Sheets"},
-    {"te", u8"షీట్‌లు"},
-    {"th", u8"ชีต"},
-    {"tr", u8"E-Tablolar"},
-    {"uk", u8"Таблиці"},
-    {"ur", u8"شیٹس"},
-    {"vi", u8"Trang tính"},
-    {"cy", u8"Dalenni"},
-    {"zu", u8"AmaSpredishithi"},
-};
-// clang-format on
-
-}  // namespace
-
 ExternalInstallOptions GetConfigForGoogleSheets() {
   ExternalInstallOptions options(
       /*install_url=*/GURL("https://docs.google.com/spreadsheets/"
@@ -109,9 +27,7 @@
   options.only_use_app_info_factory = true;
   options.app_info_factory = base::BindRepeating([]() {
     auto info = std::make_unique<WebApplicationInfo>();
+    info->title = base::UTF8ToUTF16("Sheets");
-    info->title =
-        base::UTF8ToUTF16(GetTranslatedName("Sheets", kNameTranslations));
-
     info->start_url =
         GURL("https://docs.google.com/spreadsheets/?usp=installed_webapp");
     info->scope = GURL("https://docs.google.com/spreadsheets/");
--- b/chrome/browser/web_applications/preinstalled_web_apps/google_slides.cc
+++ a/chrome/browser/web_applications/preinstalled_web_apps/google_slides.cc
@@ -13,88 +13,6 @@
 
 namespace web_app {
 
-namespace {
-
-// clang-format off
-constexpr Translation kNameTranslations[] = {
-    {"af", u8"Skyfies"},
-    {"am", u8"ስላይዶች"},
-    {"ar", u8"العروض التقديمية"},
-    {"hy", u8"Սլայդներ"},
-    {"az", u8"Slaydlar"},
-    {"eu", u8"Aurkezpenak"},
-    {"be", u8"Прэзентацыі"},
-    {"bn", u8"Slides"},
-    {"bg", u8"Презентации"},
-    {"my", u8"ဆလိုက်များ"},
-    {"ca", u8"Presentacions"},
-    {"zh-HK", u8"簡報"},
-    {"zh-CN", u8"幻灯片"},
-    {"zh-TW", u8"簡報"},
-    {"hr", u8"Prezentacije"},
-    {"cs", u8"Prezentace"},
-    {"da", u8"Præsentationer"},
-    {"nl", u8"Presentaties"},
-    {"en-GB", u8"Slides"},
-    {"et", u8"Esitlused"},
-    {"fil", u8"Mga Slide"},
-    {"fi", u8"Slides"},
-    {"fr", u8"Présentations"},
-    {"fr-CA", u8"Présentations"},
-    {"gl", u8"Presentacións"},
-    {"ka", u8"Slides"},
-    {"de", u8"Präsentationen"},
-    {"el", u8"Παρουσιάσεις"},
-    {"gu", u8"Slides"},
-    {"iw", u8"Slides"},
-    {"hi", u8"Slides"},
-    {"hu", u8"Diák"},
-    {"is", u8"Skyggnur"},
-    {"id", u8"Slide"},
-    {"it", u8"Presentazioni"},
-    {"ja", u8"スライド"},
-    {"kn", u8"Slides"},
-    {"kk", u8"Slides"},
-    {"km", u8"បទបង្ហាញ"},
-    {"ko", u8"프레젠테이션"},
-    {"lo", u8"ສະໄລ້"},
-    {"lv", u8"Prezentācijas"},
-    {"lt", u8"Skaidrės"},
-    {"ms", u8"Slaid"},
-    {"ml", u8"Slides"},
-    {"mr", u8"Slides"},
-    {"mn", u8"Слайд"},
-    {"ne", u8"स्लाइड"},
-    {"no", u8"Presentasjoner"},
-    {"fa", u8"اسلایدنگار"},
-    {"pl", u8"Prezentacje"},
-    {"pt-BR", u8"Apresentações"},
-    {"pt-PT", u8"Slides"},
-    {"pa", u8"Slides"},
-    {"ro", u8"Prezentări"},
-    {"ru", u8"Презентация"},
-    {"sr", u8"Презентације"},
-    {"si", u8"Slides"},
-    {"sk", u8"Prezentácie"},
-    {"sl", u8"Predstavitve"},
-    {"es", u8"Presentaciones"},
-    {"es-419", u8"Presentaciones"},
-    {"sw", u8"Slaidi"},
-    {"sv", u8"Presentationer"},
-    {"ta", u8"Slides"},
-    {"te", u8"Slides"},
-    {"th", u8"สไลด์"},
-    {"tr", u8"Slaytlar"},
-    {"uk", u8"Презентації"},
-    {"ur", u8"سلائیڈز"},
-    {"vi", u8"Trang trình bày"},
-    {"cy", u8"Sleidiau"},
-    {"zu", u8"Amaslayidi"},
-};
-// clang-format on
-
-}  // namespace
-
 ExternalInstallOptions GetConfigForGoogleSlides() {
   ExternalInstallOptions options(
       /*install_url=*/GURL("https://docs.google.com/presentation/"
@@ -109,8 +27,7 @@
   options.only_use_app_info_factory = true;
   options.app_info_factory = base::BindRepeating([]() {
     auto info = std::make_unique<WebApplicationInfo>();
+    info->title = base::UTF8ToUTF16("Slides");
-    info->title =
-        base::UTF8ToUTF16(GetTranslatedName("Slides", kNameTranslations));
     info->start_url =
         GURL("https://docs.google.com/presentation/?usp=installed_webapp");
     info->scope = GURL("https://docs.google.com/presentation/");
--- b/chrome/browser/web_applications/preinstalled_web_apps/preinstalled_web_app_utils.cc
+++ a/chrome/browser/web_applications/preinstalled_web_apps/preinstalled_web_app_utils.cc
@@ -4,24 +4,10 @@
 
 #include "chrome/browser/web_applications/preinstalled_web_apps/preinstalled_web_app_utils.h"
 
-#include "chrome/browser/browser_process.h"
-#include "third_party/icu/source/common/unicode/localematcher.h"
 #include "ui/base/resource/resource_bundle.h"
 
 namespace web_app {
 
-namespace {
-
-icu::Locale GetLocaleFromTranslation(const Translation& translation) {
-  UErrorCode error = U_ZERO_ERROR;
-  icu::Locale locale =
-      icu::Locale::forLanguageTag(translation.bcp47_locale, error);
-  DCHECK(U_SUCCESS(error));
-  return locale;
-}
-
-}  // namespace
-
 std::map<SquareSizePx, SkBitmap> LoadBundledIcons(
     const std::initializer_list<int>& icon_resource_ids) {
   std::map<SquareSizePx, SkBitmap> results;
@@ -34,28 +20,4 @@
   return results;
 }
 
-const char* GetTranslatedName(const char* utf8_default_name,
-                              base::span<const Translation> translations) {
-  UErrorCode error = U_ZERO_ERROR;
-  icu::LocaleMatcher matcher = icu::LocaleMatcher::Builder()
-                                   .setSupportedLocalesViaConverter(
-                                       translations.begin(), translations.end(),
-                                       GetLocaleFromTranslation)
-                                   .build(error);
-  DCHECK(U_SUCCESS(error));
-
-  icu::Locale application_locale = icu::Locale::forLanguageTag(
-      g_browser_process->GetApplicationLocale(), error);
-  DCHECK(U_SUCCESS(error));
-
-  int32_t best_index =
-      matcher.getBestMatchResult(application_locale, error).getSupportedIndex();
-  DCHECK(U_SUCCESS(error));
-
-  if (best_index == -1)
-    return utf8_default_name;
-
-  return translations[best_index].utf8_translation;
-}
-
 }  // namespace web_app
--- b/chrome/browser/web_applications/preinstalled_web_apps/preinstalled_web_app_utils.h
+++ a/chrome/browser/web_applications/preinstalled_web_apps/preinstalled_web_app_utils.h
@@ -12,14 +12,6 @@
 std::map<SquareSizePx, SkBitmap> LoadBundledIcons(
     const std::initializer_list<int>& icon_resource_ids);
 
-struct Translation {
-  const char* bcp47_locale;
-  const char* utf8_translation;
-};
-
-const char* GetTranslatedName(const char* utf8_default_name,
-                              base::span<const Translation> translations);
-
 }  // namespace web_app
 
 #endif  // CHROME_BROWSER_WEB_APPLICATIONS_PREINSTALLED_WEB_APPS_PREINSTALLED_WEB_APP_UTILS_H_
--- b/chrome/browser/web_applications/preinstalled_web_apps/preinstalled_web_app_utils_unittest.cc
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright (c) 2018 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/browser/web_applications/preinstalled_web_apps/preinstalled_web_app_utils.h"
-
-#include "chrome/browser/browser_process.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace web_app {
-
-class PreinstalledWebAppUtilsTest : public testing::Test {
- public:
-  PreinstalledWebAppUtilsTest() = default;
-  PreinstalledWebAppUtilsTest(const PreinstalledWebAppUtilsTest&) = delete;
-  PreinstalledWebAppUtilsTest& operator=(const PreinstalledWebAppUtilsTest&) =
-      delete;
-  ~PreinstalledWebAppUtilsTest() override = default;
-};
-
-TEST_F(PreinstalledWebAppUtilsTest, GetTranslatedName) {
-  std::string test_locale;
-  constexpr Translation kTranslations[] = {
-      {"en", "en"},
-      {"en-GB", "en-GB"},
-      {"fr", "fr"},
-  };
-
-  auto test = [&](const char* application_locale) -> std::string {
-    test_locale = application_locale;
-    g_browser_process->SetApplicationLocale(test_locale);
-    return GetTranslatedName("default", kTranslations);
-  };
-
-  EXPECT_EQ(test("en"), "en");
-  EXPECT_EQ(test("en-US"), "en");
-  EXPECT_EQ(test("en-GB"), "en-GB");
-  EXPECT_EQ(test("fr"), "fr");
-  EXPECT_EQ(test("fr-CA"), "fr");
-  EXPECT_EQ(test("ko"), "default");
-}
-
-}  // namespace web_app
--- a/v8/src/objects/intl-objects.h
+++ b/v8/src/objects/intl-objects.h
@@ -20,8 +20,9 @@
 #include "src/objects/objects.h"
 #include "unicode/locid.h"
 #include "unicode/uversion.h"
+#include "unicode/dtitvfmt.h"
 
-#define V8_MINIMUM_ICU_VERSION 68
+#define V8_MINIMUM_ICU_VERSION 63
 
 namespace U_ICU_NAMESPACE {
 class BreakIterator;
@@ -37,6 +38,14 @@ template <typename T>
 class Handle;
 class JSCollator;
 
+Maybe<icu::Locale> CreateICULocale(const std::string& bcp47_locale);
+
+Maybe<std::string> CanonicalizeLanguageTag(Isolate* isolate,
+                                           Handle<Object> locale_in);
+
+Maybe<std::string> CanonicalizeLanguageTag(Isolate* isolate,
+                                           const std::string& locale);
+
 class Intl {
  public:
   enum class BoundFunctionContextSlot {
@@ -189,8 +198,8 @@ class Intl {
       int32_t end);
 
   // Helper function to convert a FormattedValue to String
-  V8_WARN_UNUSED_RESULT static MaybeHandle<String> FormattedToString(
-      Isolate* isolate, const icu::FormattedValue& formatted);
+  V8_WARN_UNUSED_RESULT static MaybeHandle<String> FormattedDateIntervalToString(
+      Isolate* isolate, const icu::DateInterval& interval, const icu::DateIntervalFormat& format);
 
   // Helper function to convert number field id to type string.
   static Handle<String> NumberFieldToType(Isolate* isolate,
@@ -284,22 +293,24 @@ class Intl {
   class AvailableLocales {
    public:
     AvailableLocales() {
-      UErrorCode status = U_ZERO_ERROR;
-      UEnumeration* uenum =
-          uloc_openAvailableByType(ULOC_AVAILABLE_WITH_LEGACY_ALIASES, &status);
-      DCHECK(U_SUCCESS(status));
+      int32_t num_locales = 0;
+      const icu::Locale* icu_available_locales =
+          icu::Locale::getAvailableLocales(num_locales);
 
       std::vector<std::string> all_locales;
-      const char* loc;
-      while ((loc = uenum_next(uenum, nullptr, &status)) != nullptr) {
-        DCHECK(U_SUCCESS(status));
-        std::string locstr(loc);
+      for (int32_t num = 0; num < num_locales; num++) {
+        const icu::Locale* locale = icu_available_locales++;
+        std::string locstr(locale->getName());
         std::replace(locstr.begin(), locstr.end(), '_', '-');
         // Handle special case
         if (locstr == "en-US-POSIX") locstr = "en-US-u-va-posix";
         all_locales.push_back(locstr);
       }
-      uenum_close(uenum);
+
+      // Include legacy and alias locales.
+      for (std::string locstr : {"ars","az-AZ","bs-BA","en-NH","en-RH","ff-CM","ff-GN","ff-MR","ff-SN","in","in-ID","iw","iw-IL","ks-Arab-IN","mni-IN","mo","no","no-NO","no-NO-NY","pa-IN","pa-PK","sat-IN","sd-PK","sh","sh-BA","sh-CS","sh-YU","shi-MA","sr-BA","sr-CS","sr-Cyrl-CS","sr-Cyrl-YU","sr-Latn-CS","sr-Latn-YU","sr-ME","sr-RS","sr-XK","sr-YU","su-ID","tl","tl-PH","uz-AF","uz-UZ","vai-LR","yue-CN","yue-HK","zh-CN","zh-HK","zh-MO","zh-TW","zh-SG"}) {
+        all_locales.push_back(locstr);
+      }
 
       set_ = Intl::BuildLocaleSet(all_locales, C::path(), C::key());
     }
--- a/v8/src/objects/js-list-format.cc
+++ b/v8/src/objects/js-list-format.cc
@@ -30,26 +30,46 @@ namespace internal {
 
 namespace {
 
-UListFormatterWidth GetIcuWidth(JSListFormat::Style style) {
-  switch (style) {
-    case JSListFormat::Style::LONG:
-      return ULISTFMT_WIDTH_WIDE;
-    case JSListFormat::Style::SHORT:
-      return ULISTFMT_WIDTH_SHORT;
-    case JSListFormat::Style::NARROW:
-      return ULISTFMT_WIDTH_NARROW;
-  }
-  UNREACHABLE();
-}
-
-UListFormatterType GetIcuType(JSListFormat::Type type) {
+// from chromium 87
+const char* kStandard = "standard";
+const char* kOr = "or";
+const char* kUnit = "unit";
+const char* kStandardShort = "standard-short";
+const char* kOrShort = "or-short";
+const char* kUnitShort = "unit-short";
+const char* kStandardNarrow = "standard-narrow";
+const char* kOrNarrow = "or-narrow";
+const char* kUnitNarrow = "unit-narrow";
+const char* GetIcuStyleString(JSListFormat::Style style,
+                              JSListFormat::Type type) {
   switch (type) {
     case JSListFormat::Type::CONJUNCTION:
-      return ULISTFMT_TYPE_AND;
+      switch (style) {
+        case JSListFormat::Style::LONG:
+          return kStandard;
+        case JSListFormat::Style::SHORT:
+          return kStandardShort;
+        case JSListFormat::Style::NARROW:
+          return kStandardNarrow;
+      }
     case JSListFormat::Type::DISJUNCTION:
-      return ULISTFMT_TYPE_OR;
+      switch (style) {
+        case JSListFormat::Style::LONG:
+          return kOr;
+        case JSListFormat::Style::SHORT:
+          return kOrShort;
+        case JSListFormat::Style::NARROW:
+          return kOrNarrow;
+      }
     case JSListFormat::Type::UNIT:
-      return ULISTFMT_TYPE_UNITS;
+      switch (style) {
+        case JSListFormat::Style::LONG:
+          return kUnit;
+        case JSListFormat::Style::SHORT:
+          return kUnitShort;
+        case JSListFormat::Style::NARROW:
+          return kUnitNarrow;
+      }
   }
   UNREACHABLE();
 }
@@ -124,7 +144,7 @@ MaybeHandle<JSListFormat> JSListFormat::
   icu::Locale icu_locale = r.icu_locale;
   UErrorCode status = U_ZERO_ERROR;
   icu::ListFormatter* formatter = icu::ListFormatter::createInstance(
-      icu_locale, GetIcuType(type_enum), GetIcuWidth(style_enum), status);
+      icu_locale, GetIcuStyleString(style_enum, type_enum), status);
   if (U_FAILURE(status) || formatter == nullptr) {
     delete formatter;
     THROW_NEW_ERROR(isolate, NewRangeError(MessageTemplate::kIcuError),
@@ -227,7 +247,7 @@ Maybe<std::vector<icu::UnicodeString>> T
 template <typename T>
 MaybeHandle<T> FormatListCommon(
     Isolate* isolate, Handle<JSListFormat> format, Handle<JSArray> list,
-    MaybeHandle<T> (*formatToResult)(Isolate*, const icu::FormattedValue&)) {
+    MaybeHandle<T> (*formatToResult)(Isolate*, const icu::UnicodeString&, const std::vector<icu::UnicodeString>&)) {
   DCHECK(!list->IsUndefined());
   Maybe<std::vector<icu::UnicodeString>> maybe_array =
       ToUnicodeStringArray(isolate, list);
@@ -238,49 +258,67 @@ MaybeHandle<T> FormatListCommon(
   DCHECK_NOT_NULL(formatter);
 
   UErrorCode status = U_ZERO_ERROR;
-  icu::FormattedList formatted = formatter->formatStringsToValue(
-      array.data(), static_cast<int32_t>(array.size()), status);
+  icu::UnicodeString formatted;
+  formatter->format(array.data(), static_cast<int32_t>(array.size()), formatted,
+                    status);
   if (U_FAILURE(status)) {
     THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), T);
   }
-  return formatToResult(isolate, formatted);
+  return formatToResult(isolate, formatted, array);
 }
 
-Handle<String> IcuFieldIdToType(Isolate* isolate, int32_t field_id) {
-  switch (field_id) {
-    case ULISTFMT_LITERAL_FIELD:
-      return isolate->factory()->literal_string();
-    case ULISTFMT_ELEMENT_FIELD:
-      return isolate->factory()->element_string();
-    default:
-      UNREACHABLE();
-      // To prevent MSVC from issuing C4715 warning.
-      return Handle<String>();
-  }
+MaybeHandle<String> FormattedListToString(
+    Isolate* isolate, const icu::UnicodeString& formatted, const std::vector<icu::UnicodeString>& items) {
+    return Intl::ToString(isolate, formatted);
 }
 
 // A helper function to convert the FormattedList to a
 // MaybeHandle<JSArray> for the implementation of formatToParts.
 MaybeHandle<JSArray> FormattedListToJSArray(
-    Isolate* isolate, const icu::FormattedValue& formatted) {
-  Handle<JSArray> array = isolate->factory()->NewJSArray(0);
-  icu::ConstrainedFieldPosition cfpos;
-  cfpos.constrainCategory(UFIELD_CATEGORY_LIST);
+    Isolate* isolate, const icu::UnicodeString& formatted, const std::vector<icu::UnicodeString>& items) {
+// From chromium 70
+// This is a temporary workaround until icu::ListFormat support FieldPosition
+// It is inefficient and won't work correctly on the edge case that the input
+// contains fraction of the list pattern.
+// For example the following under English will mark the "an" incorrectly
+// since the formatted is "a, b, and an".
+// listFormat.formatToParts(["a", "b", "an"])
+// https://ssl.icu-project.org/trac/ticket/13754
+  Factory* factory = isolate->factory();
+  int length = items.size();
+  int estimate_size = length * 2 + 1;
+  Handle<JSArray> array = factory->NewJSArray(estimate_size);
   int index = 0;
-  UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString string = formatted.toString(status);
-  Handle<String> substring;
-  while (formatted.nextPosition(cfpos, status) && U_SUCCESS(status)) {
+  int last_pos = 0;
+  for (int i = 0; i < length; i++) {
+    int found = formatted.indexOf(items[i], last_pos);
+    DCHECK_GE(found, 0);
+    if (found > last_pos) {
+      Handle<String> substring;
+      ASSIGN_RETURN_ON_EXCEPTION(
+          isolate, substring,
+          Intl::ToString(isolate, formatted, last_pos, found), JSArray);
+      Intl::AddElement(isolate, array, index++, factory->literal_string(),
+                       substring);
+    }
+    last_pos = found + items[i].length();
+    Handle<String> substring;
     ASSIGN_RETURN_ON_EXCEPTION(
-        isolate, substring,
-        Intl::ToString(isolate, string, cfpos.getStart(), cfpos.getLimit()),
+        isolate, substring, Intl::ToString(isolate, formatted, found, last_pos),
         JSArray);
-    Intl::AddElement(isolate, array, index++,
-                     IcuFieldIdToType(isolate, cfpos.getField()), substring);
+    Intl::AddElement(isolate, array, index++, factory->element_string(),
+                     substring);
   }
-  if (U_FAILURE(status)) {
-    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), JSArray);
+  if (last_pos < formatted.length()) {
+    Handle<String> substring;
+    ASSIGN_RETURN_ON_EXCEPTION(
+        isolate, substring,
+        Intl::ToString(isolate, formatted, last_pos, formatted.length()),
+        JSArray);
+    Intl::AddElement(isolate, array, index++, factory->literal_string(),
+                     substring);
   }
+
   JSObject::ValidateElements(*array);
   return array;
 }
@@ -292,7 +330,7 @@ MaybeHandle<String> JSListFormat::Format
                                              Handle<JSListFormat> format,
                                              Handle<JSArray> list) {
   return FormatListCommon<String>(isolate, format, list,
-                                  Intl::FormattedToString);
+                                  FormattedListToString);
 }
 
 // ecma42 #sec-formatlisttoparts
--- a/v8/src/objects/js-relative-time-format.cc
+++ b/v8/src/objects/js-relative-time-format.cc
@@ -19,7 +19,7 @@
 #include "src/objects/js-relative-time-format-inl.h"
 #include "src/objects/objects-inl.h"
 #include "unicode/decimfmt.h"
-#include "unicode/numfmt.h"
+#include "unicode/numberformatter.h"
 #include "unicode/reldatefmt.h"
 #include "unicode/unum.h"
 
@@ -287,6 +287,65 @@ Handle<String> JSRelativeTimeFormat::Num
 
 namespace {
 
+// From chromium 74
+MaybeHandle<JSArray> GenerateRelativeTimeFormatParts(
+    Isolate* isolate, const icu::UnicodeString& formatted,
+    const icu::UnicodeString& integer_part, const Handle<String>& unit,
+    double number, const icu::number::LocalizedNumberFormatter& nf) {
+  Factory* factory = isolate->factory();
+  Handle<JSArray> array = factory->NewJSArray(0);
+  int32_t found = formatted.indexOf(integer_part);
+
+  Handle<String> substring;
+  if (found < 0) {
+    // Cannot find the integer_part in the formatted.
+    // Return [{'type': 'literal', 'value': formatted}]
+    ASSIGN_RETURN_ON_EXCEPTION(isolate, substring,
+                               Intl::ToString(isolate, formatted), JSArray);
+    Intl::AddElement(isolate, array,
+                     0,                          // index
+                     factory->literal_string(),  // field_type_string
+                     substring);
+  } else {
+    // Found the formatted integer in the result.
+    int index = 0;
+
+    // array.push({
+    //     'type': 'literal',
+    //     'value': formatted.substring(0, found)})
+    if (found > 0) {
+      ASSIGN_RETURN_ON_EXCEPTION(isolate, substring,
+                                 Intl::ToString(isolate, formatted, 0, found),
+                                 JSArray);
+      Intl::AddElement(isolate, array, index++,
+                       factory->literal_string(),  // field_type_string
+                       substring);
+    }
+
+    Handle<Object> number_obj = factory->NewNumber(number);
+    Maybe<int> maybe_format_to_parts = JSNumberFormat::FormatToParts(
+        isolate, array, index, nf, number_obj, unit);
+    MAYBE_RETURN(maybe_format_to_parts, Handle<JSArray>());
+    index = maybe_format_to_parts.FromJust();
+
+    // array.push({
+    //     'type': 'literal',
+    //     'value': formatted.substring(
+    //         found + integer_part.length, formatted.length)})
+    if (found + integer_part.length() < formatted.length()) {
+      ASSIGN_RETURN_ON_EXCEPTION(
+          isolate, substring,
+          Intl::ToString(isolate, formatted, found + integer_part.length(),
+                         formatted.length()),
+          JSArray);
+      Intl::AddElement(isolate, array, index,
+                       factory->literal_string(),  // field_type_string
+                       substring);
+    }
+  }
+  return array;
+}
+
 Handle<String> UnitAsString(Isolate* isolate, URelativeDateTimeUnit unit_enum) {
   Factory* factory = isolate->factory();
   switch (unit_enum) {
@@ -349,7 +408,8 @@ MaybeHandle<T> FormatCommon(
     Isolate* isolate, Handle<JSRelativeTimeFormat> format,
     Handle<Object> value_obj, Handle<Object> unit_obj, const char* func_name,
     MaybeHandle<T> (*formatToResult)(Isolate*,
-                                     const icu::FormattedRelativeDateTime&,
+                                     const icu::UnicodeString&,
+                                     const icu::number::LocalizedNumberFormatter&,
                                      Handle<Object>, Handle<String>)) {
   // 3. Let value be ? ToNumber(value).
   Handle<Object> value;
@@ -379,26 +439,37 @@ MaybeHandle<T> FormatCommon(
                       unit),
         T);
   }
+
   UErrorCode status = U_ZERO_ERROR;
-  icu::FormattedRelativeDateTime formatted =
-      (format->numeric() == JSRelativeTimeFormat::Numeric::ALWAYS)
-          ? formatter->formatNumericToValue(number, unit_enum, status)
-          : formatter->formatToValue(number, unit_enum, status);
+  icu::UnicodeString formatted;
+
+  if (format->numeric() == JSRelativeTimeFormat::Numeric::ALWAYS) {
+    formatter->formatNumeric(number, unit_enum, formatted, status);
+  } else {
+    DCHECK_EQ(JSRelativeTimeFormat::Numeric::AUTO, format->numeric());
+    formatter->format(number, unit_enum, formatted, status);
+  }
+
   if (U_FAILURE(status)) {
     THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), T);
   }
-  return formatToResult(isolate, formatted, value,
-                        UnitAsString(isolate, unit_enum));
+
+  std::string locale_str(format->locale().ToCString().get());
+  Maybe<icu::Locale> maybe_icu_locale = CreateICULocale(locale_str);
+  if (maybe_icu_locale.IsNothing()) {
+    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), T);
+  }
+
+  icu::Locale icu_locale = maybe_icu_locale.FromJust();
+  return formatToResult(isolate, formatted,
+                        icu::number::NumberFormatter::withLocale(icu_locale),
+                        value, UnitAsString(isolate, unit_enum));
 }
 
 MaybeHandle<String> FormatToString(
-    Isolate* isolate, const icu::FormattedRelativeDateTime& formatted,
+    Isolate* isolate, const icu::UnicodeString& result,
+    const icu::number::LocalizedNumberFormatter& nf,
     Handle<Object> value, Handle<String> unit) {
-  UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString result = formatted.toString(status);
-  if (U_FAILURE(status)) {
-    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), String);
-  }
   return Intl::ToString(isolate, result);
 }
 
@@ -429,67 +500,32 @@ Maybe<bool> AddUnit(Isolate* isolate, Ha
 }
 
 MaybeHandle<JSArray> FormatToJSArray(
-    Isolate* isolate, const icu::FormattedRelativeDateTime& formatted,
+    Isolate* isolate, const icu::UnicodeString& formatted,
+    const icu::number::LocalizedNumberFormatter& nf,
     Handle<Object> value, Handle<String> unit) {
   UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString string = formatted.toString(status);
-
-  Factory* factory = isolate->factory();
-  Handle<JSArray> array = factory->NewJSArray(0);
-  icu::ConstrainedFieldPosition cfpos;
-  cfpos.constrainCategory(UFIELD_CATEGORY_NUMBER);
-  int32_t index = 0;
-
-  int32_t previous_end = 0;
-  Handle<String> substring;
-  std::vector<std::pair<int32_t, int32_t>> groups;
-  while (formatted.nextPosition(cfpos, status) && U_SUCCESS(status)) {
-    int32_t category = cfpos.getCategory();
-    int32_t field = cfpos.getField();
-    int32_t start = cfpos.getStart();
-    int32_t limit = cfpos.getLimit();
-    if (category == UFIELD_CATEGORY_NUMBER) {
-      if (field == UNUM_GROUPING_SEPARATOR_FIELD) {
-        groups.push_back(std::pair<int32_t, int32_t>(start, limit));
-        continue;
-      }
-      if (start > previous_end) {
-        Maybe<bool> maybe_added =
-            AddLiteral(isolate, array, string, index++, previous_end, start);
-        MAYBE_RETURN(maybe_added, Handle<JSArray>());
-      }
-      if (field == UNUM_INTEGER_FIELD) {
-        for (auto start_limit : groups) {
-          if (start_limit.first > start) {
-            Maybe<bool> maybe_added =
-                AddUnit(isolate, array, string, index++, start,
-                        start_limit.first, field, value, unit);
-            MAYBE_RETURN(maybe_added, Handle<JSArray>());
-            maybe_added = AddUnit(isolate, array, string, index++,
-                                  start_limit.first, start_limit.second,
-                                  UNUM_GROUPING_SEPARATOR_FIELD, value, unit);
-            MAYBE_RETURN(maybe_added, Handle<JSArray>());
-            start = start_limit.second;
-          }
-        }
-      }
-      Maybe<bool> maybe_added = AddUnit(isolate, array, string, index++, start,
-                                        limit, field, value, unit);
-      MAYBE_RETURN(maybe_added, Handle<JSArray>());
-      previous_end = limit;
-    }
-  }
+  double number = value->Number();
+  double abs_number = std::abs(number);
+  icu::number::FormattedNumber formatted_number
+      = nf.formatDouble(abs_number, status);
   if (U_FAILURE(status)) {
-    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), JSArray);
+    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError),
+                    JSArray);
   }
-  if (string.length() > previous_end) {
-    Maybe<bool> maybe_added = AddLiteral(isolate, array, string, index,
-                                         previous_end, string.length());
-    MAYBE_RETURN(maybe_added, Handle<JSArray>());
+
+  icu::UnicodeString number_str = formatted_number.toString(status);
+  if (U_FAILURE(status)) {
+    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError),
+                    JSArray);
   }
 
-  JSObject::ValidateElements(*array);
-  return array;
+  Handle<JSArray> elements;
+  ASSIGN_RETURN_ON_EXCEPTION(isolate, elements,
+                             GenerateRelativeTimeFormatParts(
+                                 isolate, formatted, number_str, unit,
+                                 abs_number, nf),
+                             JSArray);
+  return elements;
 }
 
 }  // namespace
--- a/v8/src/objects/intl-objects.cc
+++ b/v8/src/objects/intl-objects.cc
@@ -33,9 +33,6 @@
 #include "unicode/coll.h"
 #include "unicode/datefmt.h"
 #include "unicode/decimfmt.h"
-#include "unicode/formattedvalue.h"
-#include "unicode/localebuilder.h"
-#include "unicode/localematcher.h"
 #include "unicode/locid.h"
 #include "unicode/normalizer2.h"
 #include "unicode/numberformatter.h"
@@ -430,8 +427,6 @@ std::string Intl::GetNumberingSystem(const icu::Locale& icu_locale) {
   return "latn";
 }
 
-namespace {
-
 Maybe<icu::Locale> CreateICULocale(const std::string& bcp47_locale) {
   DisallowGarbageCollection no_gc;
 
@@ -447,8 +442,6 @@ Maybe<icu::Locale> CreateICULocale(const std::string& bcp47_locale) {
   return Just(icu_locale);
 }
 
-}  // anonymous namespace
-
 // static
 
 MaybeHandle<String> Intl::ToString(Isolate* isolate,
@@ -766,6 +759,8 @@ bool IsStructurallyValidLanguageTag(cons
   return JSLocale::StartsWithUnicodeLanguageId(tag);
 }
 
+}  // anonymous namespace
+
 // Canonicalize the locale.
 // https://tc39.github.io/ecma402/#sec-canonicalizelanguagetag,
 // including type check and structural validity check.
@@ -789,9 +789,21 @@ Maybe<std::string> CanonicalizeLanguageTag(Isolate* isolate,
         Nothing<std::string>());
   }
 
-  // Use LocaleBuilder to validate locale.
-  icu_locale = icu::LocaleBuilder().setLocale(icu_locale).build(error);
-  icu_locale.canonicalize(error);
+  // reject attribute of wrong length.
+  if (std::strstr(icu_locale.getName(), "attribute=") != nullptr) {
+    std::string attribute =
+        icu_locale.getKeywordValue<std::string>("attribute", error);
+    if (U_SUCCESS(error) &&
+        (attribute.length() < 3 || attribute.length() > 8)) {
+      THROW_NEW_ERROR_RETURN_VALUE(
+          isolate,
+          NewRangeError(
+              MessageTemplate::kInvalidLanguageTag,
+              isolate->factory()->NewStringFromAsciiChecked(locale.c_str())),
+          Nothing<std::string>());
+    }
+  }
+
   if (U_FAILURE(error) || icu_locale.isBogus()) {
     THROW_NEW_ERROR_RETURN_VALUE(
         isolate,
@@ -869,8 +864,6 @@ Maybe<std::string> CanonicalizeLanguageT
   return CanonicalizeLanguageTag(isolate, locale);
 }
 
-}  // anonymous namespace
-
 Maybe<std::vector<std::string>> Intl::CanonicalizeLocaleList(
     Isolate* isolate, Handle<Object> locales, bool only_return_one_result) {
   // 1. If locales is undefined, then
@@ -1492,114 +1485,12 @@ std::vector<std::string> LookupSupported
   return subset;
 }
 
-icu::LocaleMatcher BuildLocaleMatcher(
-    Isolate* isolate, const std::set<std::string>& available_locales,
-    UErrorCode* status) {
-  icu::Locale default_locale =
-      icu::Locale::forLanguageTag(DefaultLocale(isolate), *status);
-  DCHECK(U_SUCCESS(*status));
-  icu::LocaleMatcher::Builder builder;
-  builder.setDefaultLocale(&default_locale);
-  for (auto it = available_locales.begin(); it != available_locales.end();
-       ++it) {
-    builder.addSupportedLocale(
-        icu::Locale::forLanguageTag(it->c_str(), *status));
-  }
-
-  return builder.build(*status);
-}
-
-class Iterator : public icu::Locale::Iterator {
- public:
-  Iterator(std::vector<std::string>::const_iterator begin,
-           std::vector<std::string>::const_iterator end)
-      : iter_(begin), end_(end) {}
-  ~Iterator() override = default;
-
-  UBool hasNext() const override { return iter_ != end_; }
-
-  const icu::Locale& next() override {
-    UErrorCode status = U_ZERO_ERROR;
-    locale_ = icu::Locale::forLanguageTag(iter_->c_str(), status);
-    DCHECK(U_SUCCESS(status));
-    ++iter_;
-    return locale_;
-  }
-
- private:
-  std::vector<std::string>::const_iterator iter_;
-  std::vector<std::string>::const_iterator end_;
-  icu::Locale locale_;
-};
-
-// ecma402/#sec-bestfitmatcher
-// The BestFitMatcher abstract operation compares requestedLocales, which must
-// be a List as returned by CanonicalizeLocaleList, against the locales in
-// availableLocales and determines the best available language to meet the
-// request. The algorithm is implementation dependent, but should produce
-// results that a typical user of the requested locales would perceive
-// as at least as good as those produced by the LookupMatcher abstract
-// operation. Options specified through Unicode locale extension sequences must
-// be ignored by the algorithm. Information about such subsequences is returned
-// separately. The abstract operation returns a record with a [[locale]] field,
-// whose value is the language tag of the selected locale, which must be an
-// element of availableLocales. If the language tag of the request locale that
-// led to the selected locale contained a Unicode locale extension sequence,
-// then the returned record also contains an [[extension]] field whose value is
-// the first Unicode locale extension sequence within the request locale
-// language tag.
-std::string BestFitMatcher(Isolate* isolate,
-                           const std::set<std::string>& available_locales,
-                           const std::vector<std::string>& requested_locales) {
-  UErrorCode status = U_ZERO_ERROR;
-  icu::LocaleMatcher matcher =
-      BuildLocaleMatcher(isolate, available_locales, &status);
-  DCHECK(U_SUCCESS(status));
-
-  Iterator iter(requested_locales.cbegin(), requested_locales.cend());
-  std::string bestfit =
-      matcher.getBestMatch(iter, status)->toLanguageTag<std::string>(status);
-  if (U_FAILURE(status)) {
-    return DefaultLocale(isolate);
-  }
-  // We need to return the extensions with it.
-  for (auto it = requested_locales.begin(); it != requested_locales.end();
-       ++it) {
-    if (it->find(bestfit) == 0) {
-      return *it;
-    }
-  }
-  return bestfit;
-}
-
 // ECMA 402 9.2.8 BestFitSupportedLocales(availableLocales, requestedLocales)
 // https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales
 std::vector<std::string> BestFitSupportedLocales(
     Isolate* isolate, const std::set<std::string>& available_locales,
     const std::vector<std::string>& requested_locales) {
-  UErrorCode status = U_ZERO_ERROR;
-  icu::LocaleMatcher matcher =
-      BuildLocaleMatcher(isolate, available_locales, &status);
-  DCHECK(U_SUCCESS(status));
-
-  std::string default_locale = DefaultLocale(isolate);
-  std::vector<std::string> result;
-  for (auto it = requested_locales.cbegin(); it != requested_locales.cend();
-       it++) {
-    if (*it == default_locale) {
-      result.push_back(*it);
-    } else {
-      status = U_ZERO_ERROR;
-      icu::Locale desired = icu::Locale::forLanguageTag(it->c_str(), status);
-      std::string bestfit = matcher.getBestMatch(desired, status)
-                                ->toLanguageTag<std::string>(status);
-      // We need to return the extensions with it.
-      if (U_SUCCESS(status) && it->find(bestfit) == 0) {
-        result.push_back(*it);
-      }
-    }
-  }
-  return result;
+  return LookupSupportedLocales(available_locales, requested_locales);
 }
 
 // ecma262 #sec-createarrayfromlist
@@ -1775,8 +1666,6 @@ std::map<std::string, std::string> Looku
   std::map<std::string, std::string> extensions;
 
   UErrorCode status = U_ZERO_ERROR;
-  icu::LocaleBuilder builder;
-  builder.setLocale(*icu_locale).clearExtensions();
   std::unique_ptr<icu::StringEnumeration> keywords(
       icu_locale->createKeywords(status));
   if (U_FAILURE(status)) return extensions;
@@ -1838,14 +1727,13 @@ std::map<std::string, std::string> Looku
       if (is_valid_value) {
         extensions.insert(
             std::pair<std::string, std::string>(bcp47_key, bcp47_value));
-        builder.setUnicodeLocaleKeyword(bcp47_key, bcp47_value);
+        status = U_ZERO_ERROR;
+        icu_locale->setKeywordValue(bcp47_key, bcp47_value, status);
+        CHECK(U_SUCCESS(status));
       }
     }
   }
 
-  status = U_ZERO_ERROR;
-  *icu_locale = builder.build(status);
-
   return extensions;
 }
 
@@ -1914,8 +1802,7 @@ Maybe<Intl::ResolvedLocale> Intl::Resolv
     const std::vector<std::string>& requested_locales, MatcherOption matcher,
     const std::set<std::string>& relevant_extension_keys) {
   std::string locale;
-  if (matcher == Intl::MatcherOption::kBestFit && implement_bestfit) {
-    locale = BestFitMatcher(isolate, available_locales, requested_locales);
+  if (false) {
   } else {
     locale = LookupMatcher(isolate, available_locales, requested_locales);
   }
@@ -2221,11 +2108,6 @@ Handle<String> Intl::NumberFieldToType(I
       UNREACHABLE();
       return Handle<String>();
 
-    case UNUM_COMPACT_FIELD:
-      return isolate->factory()->compact_string();
-    case UNUM_MEASURE_UNIT_FIELD:
-      return isolate->factory()->unit_string();
-
     default:
       UNREACHABLE();
       return Handle<String>();
@@ -2233,10 +2115,13 @@ Handle<String> Intl::NumberFieldToType(I
 }
 
 // A helper function to convert the FormattedValue for several Intl objects.
-MaybeHandle<String> Intl::FormattedToString(
-    Isolate* isolate, const icu::FormattedValue& formatted) {
+MaybeHandle<String> Intl::FormattedDateIntervalToString(
+    Isolate* isolate, const icu::DateInterval& interval, const icu::DateIntervalFormat& format) {
+  icu::UnicodeString result;
+  icu::FieldPosition fpos;
+
   UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString result = formatted.toString(status);
+  format.format(&interval, result, fpos, status);
   if (U_FAILURE(status)) {
     THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), String);
   }
--- a/v8/src/objects/js-locale.cc
+++ b/v8/src/objects/js-locale.cc
@@ -21,7 +21,6 @@
 #include "src/objects/js-locale-inl.h"
 #include "src/objects/objects-inl.h"
 #include "unicode/char16ptr.h"
-#include "unicode/localebuilder.h"
 #include "unicode/locid.h"
 #include "unicode/uloc.h"
 #include "unicode/unistr.h"
@@ -41,7 +40,7 @@ struct OptionData {
 // Inserts tags from options into locale string.
 Maybe<bool> InsertOptionsIntoLocale(Isolate* isolate,
                                     Handle<JSReceiver> options,
-                                    icu::LocaleBuilder* builder) {
+                                    icu::Locale* icu_locale) {
   DCHECK(isolate);
 
   const std::vector<const char*> hour_cycle_values = {"h11", "h12", "h23",
@@ -60,6 +59,7 @@ Maybe<bool> InsertOptionsIntoLocale(Isol
   // TODO(cira): Pass in values as per the spec to make this to be
   // spec compliant.
 
+  UErrorCode status = U_ZERO_ERROR;
   for (const auto& option_to_bcp47 : kOptionToUnicodeTagMap) {
     std::unique_ptr<char[]> value_str = nullptr;
     bool value_bool = false;
@@ -84,10 +84,16 @@ Maybe<bool> InsertOptionsIntoLocale(Isol
 
     // Overwrite existing, or insert new key-value to the locale string.
     if (!uloc_toLegacyType(uloc_toLegacyKey(option_to_bcp47.key),
-                           value_str.get())) {
+                          value_str.get())) {
       return Just(false);
+    } else {
+      // Only call setUnicodeKeywordValue if that value is a valid one.
+      icu_locale->setUnicodeKeywordValue(option_to_bcp47.key, value_str.get(),
+                                         status);
+      if (U_FAILURE(status)) {
+        return Just(false);
+      }
     }
-    builder->setUnicodeLocaleKeyword(option_to_bcp47.key, value_str.get());
   }
   return Just(true);
 }
@@ -142,16 +141,6 @@ bool IsUnicodeLanguageSubtag(const std::string& value) {
   return IsAlpha(value, 2, 3) || IsAlpha(value, 5, 8);
 }
 
-bool IsUnicodeScriptSubtag(const std::string& value) {
-  // unicode_script_subtag = alpha{4} ;
-  return IsAlpha(value, 4, 4);
-}
-
-bool IsUnicodeRegionSubtag(const std::string& value) {
-  // unicode_region_subtag = (alpha{2} | digit{3});
-  return IsAlpha(value, 2, 2) || IsDigit(value, 3, 3);
-}
-
 bool IsDigitAlphanum3(const std::string& value) {
   return value.length() == 4 && base::IsInRange(value[0], '0', '9') &&
          IsAlphanum(value.substr(1), 3, 3);
@@ -170,6 +166,16 @@ bool IsExtensionSingleton(const std::str
 }
 }  // namespace
 
+bool IsUnicodeScriptSubtag(const std::string& value) {
+  // unicode_script_subtag = alpha{4} ;
+  return IsAlpha(value, 4, 4);
+}
+
+bool IsUnicodeRegionSubtag(const std::string& value) {
+  // unicode_region_subtag = (alpha{2} | digit{3});
+  return IsAlpha(value, 2, 2) || IsDigit(value, 3, 3);
+}
+
 bool JSLocale::Is38AlphaNumList(const std::string& value) {
   std::size_t found = value.find("-");
   if (found == std::string::npos) {
@@ -223,8 +229,7 @@ bool JSLocale::StartsWithUnicodeLanguage
 
 namespace {
 Maybe<bool> ApplyOptionsToTag(Isolate* isolate, Handle<String> tag,
-                              Handle<JSReceiver> options,
-                              icu::LocaleBuilder* builder) {
+                              Handle<JSReceiver> options) {
   v8::Isolate* v8_isolate = reinterpret_cast<v8::Isolate*>(isolate);
   if (tag->length() == 0) {
     THROW_NEW_ERROR_RETURN_VALUE(
@@ -233,7 +238,6 @@ Maybe<bool> ApplyOptionsToTag(Isolate* i
   }
 
   v8::String::Utf8Value bcp47_tag(v8_isolate, v8::Utils::ToLocal(tag));
-  builder->setLanguageTag({*bcp47_tag, bcp47_tag.length()});
   DCHECK_LT(0, bcp47_tag.length());
   DCHECK_NOT_NULL(*bcp47_tag);
   // 2. If IsStructurallyValidLanguageTag(tag) is false, throw a RangeError
@@ -239,12 +239,11 @@ Maybe<bool> ApplyOptionsToTag(Isolate* isolate, Handle<String> tag,
     return Just(false);
   }
   UErrorCode status = U_ZERO_ERROR;
-  icu::Locale canonicalized = builder->build(status);
-  canonicalized.canonicalize(status);
+  icu::Locale icu_locale =
+      icu::Locale::forLanguageTag({*bcp47_tag, bcp47_tag.length()}, status);
   if (U_FAILURE(status)) {
     return Just(false);
   }
-  builder->setLocale(canonicalized);
 
   // 3. Let language be ? GetOption(options, "language", "string", undefined,
   // undefined).
@@ -256,11 +255,9 @@ Maybe<bool> ApplyOptionsToTag(Isolate* isolate, Handle<String> tag,
   MAYBE_RETURN(maybe_language, Nothing<bool>());
   // 4. If language is not undefined, then
   if (maybe_language.FromJust()) {
-    builder->setLanguage(language_str.get());
-    builder->build(status);
     // a. If language does not match the unicode_language_subtag production,
     //    throw a RangeError exception.
-    if (U_FAILURE(status) || language_str[0] == '\0' ||
+    if (!IsUnicodeLanguageSubtag(language_str.get()) || language_str[0] == '\0' ||
         IsAlpha(language_str.get(), 4, 4)) {
       return Just(false);
     }
@@ -275,11 +278,9 @@ Maybe<bool> ApplyOptionsToTag(Isolate* i
   MAYBE_RETURN(maybe_script, Nothing<bool>());
   // 6. If script is not undefined, then
   if (maybe_script.FromJust()) {
-    builder->setScript(script_str.get());
-    builder->build(status);
     // a. If script does not match the unicode_script_subtag production, throw
     //    a RangeError exception.
-    if (U_FAILURE(status) || script_str[0] == '\0') {
+    if (!IsUnicodeScriptSubtag(script_str.get()) || script_str[0] == '\0') {
       return Just(false);
     }
   }
@@ -294,9 +295,7 @@ Maybe<bool> ApplyOptionsToTag(Isolate* i
   if (maybe_region.FromJust()) {
     // a. If region does not match the region production, throw a RangeError
     // exception.
-    builder->setRegion(region_str.get());
-    builder->build(status);
-    if (U_FAILURE(status) || region_str[0] == '\0') {
+    if (!IsUnicodeRegionSubtag(region_str.get()) || region_str[0] == '\0') {
       return Just(false);
     }
   }
@@ -331,9 +330,8 @@ Maybe<bool> ApplyOptionsToTag(Isolate* i
 MaybeHandle<JSLocale> JSLocale::New(Isolate* isolate, Handle<Map> map,
                                     Handle<String> locale_str,
                                     Handle<JSReceiver> options) {
-  icu::LocaleBuilder builder;
   Maybe<bool> maybe_apply =
-      ApplyOptionsToTag(isolate, locale_str, options, &builder);
+      ApplyOptionsToTag(isolate, locale_str, options);
   MAYBE_RETURN(maybe_apply, MaybeHandle<JSLocale>());
   if (!maybe_apply.FromJust()) {
     THROW_NEW_ERROR(isolate,
@@ -340,15 +337,22 @@ MaybeHandle<JSLocale> JSLocale::New(Isolate* isolate, Handle<Map> map,
                     JSLocale);
   }
 
-  Maybe<bool> maybe_insert =
-      InsertOptionsIntoLocale(isolate, options, &builder);
-  MAYBE_RETURN(maybe_insert, MaybeHandle<JSLocale>());
+  Maybe<std::string> maybe_locale =
+      CanonicalizeLanguageTag(isolate, locale_str);
+  MAYBE_RETURN(maybe_locale, MaybeHandle<JSLocale>());
   UErrorCode status = U_ZERO_ERROR;
-  icu::Locale icu_locale = builder.build(status);
-
-  icu_locale.canonicalize(status);
+  icu::Locale icu_locale =
+      icu::Locale::forLanguageTag(maybe_locale.FromJust().c_str(), status);
+  if (U_FAILURE(status)) {
+    THROW_NEW_ERROR(isolate,
+                    NewRangeError(MessageTemplate::kLocaleBadParameters),
+                    JSLocale);
+  }
 
-  if (!maybe_insert.FromJust() || U_FAILURE(status)) {
+  Maybe<bool> maybe_insert =
+      InsertOptionsIntoLocale(isolate, options, &icu_locale);
+  MAYBE_RETURN(maybe_insert, MaybeHandle<JSLocale>());
+  if (!maybe_insert.FromJust()) {
     THROW_NEW_ERROR(isolate,
                     NewRangeError(MessageTemplate::kLocaleBadParameters),
                     JSLocale);
@@ -392,62 +392,22 @@ MaybeHandle<JSLocale> Construct(Isolate* isolate,
 
 MaybeHandle<JSLocale> JSLocale::Maximize(Isolate* isolate,
                                          Handle<JSLocale> locale) {
-  // ICU has limitation on the length of the locale while addLikelySubtags
-  // is called. Work around the issue by only perform addLikelySubtags
-  // on the base locale and merge the extension if needed.
-  icu::Locale source(*(locale->icu_locale().raw()));
-  icu::Locale result = icu::Locale::createFromName(source.getBaseName());
+  icu::Locale icu_locale(*(locale->icu_locale().raw()));
   UErrorCode status = U_ZERO_ERROR;
-  result.addLikelySubtags(status);
-  if (strlen(source.getBaseName()) != strlen(result.getBaseName())) {
-    // Base name is changed
-    if (strlen(source.getBaseName()) != strlen(source.getName())) {
-      // the source has extensions, get the extensions from the source.
-      result = icu::LocaleBuilder()
-                   .setLocale(source)
-                   .setLanguage(result.getLanguage())
-                   .setRegion(result.getCountry())
-                   .setScript(result.getScript())
-                   .setVariant(result.getVariant())
-                   .build(status);
-    }
-  } else {
-    // Base name is not changed
-    result = source;
-  }
+  icu_locale.addLikelySubtags(status);
   DCHECK(U_SUCCESS(status));
-  DCHECK(!result.isBogus());
-  return Construct(isolate, result);
+  DCHECK(!icu_locale.isBogus());
+  return Construct(isolate, icu_locale);
 }
 
 MaybeHandle<JSLocale> JSLocale::Minimize(Isolate* isolate,
                                          Handle<JSLocale> locale) {
-  // ICU has limitation on the length of the locale while minimizeSubtags
-  // is called. Work around the issue by only perform addLikelySubtags
-  // on the base locale and merge the extension if needed.
-  icu::Locale source(*(locale->icu_locale().raw()));
-  icu::Locale result = icu::Locale::createFromName(source.getBaseName());
+  icu::Locale icu_locale(*(locale->icu_locale().raw()));
   UErrorCode status = U_ZERO_ERROR;
-  result.minimizeSubtags(status);
-  if (strlen(source.getBaseName()) != strlen(result.getBaseName())) {
-    // Base name is changed
-    if (strlen(source.getBaseName()) != strlen(source.getName())) {
-      // the source has extensions, get the extensions from the source.
-      result = icu::LocaleBuilder()
-                   .setLocale(source)
-                   .setLanguage(result.getLanguage())
-                   .setRegion(result.getCountry())
-                   .setScript(result.getScript())
-                   .setVariant(result.getVariant())
-                   .build(status);
-    }
-  } else {
-    // Base name is not changed
-    result = source;
-  }
+  icu_locale.minimizeSubtags(status);
   DCHECK(U_SUCCESS(status));
-  DCHECK(!result.isBogus());
-  return Construct(isolate, result);
+  DCHECK(!icu_locale.isBogus());
+  return Construct(isolate, icu_locale);
 }
 
 Handle<Object> JSLocale::Language(Isolate* isolate, Handle<JSLocale> locale) {
--- a/v8/src/objects/js-date-time-format.cc
+++ b/v8/src/objects/js-date-time-format.cc
@@ -59,21 +59,6 @@ JSDateTimeFormat::HourCycle ToHourCycle(
   return JSDateTimeFormat::HourCycle::kUndefined;
 }
 
-JSDateTimeFormat::HourCycle ToHourCycle(UDateFormatHourCycle hc) {
-  switch (hc) {
-    case UDAT_HOUR_CYCLE_11:
-      return JSDateTimeFormat::HourCycle::kH11;
-    case UDAT_HOUR_CYCLE_12:
-      return JSDateTimeFormat::HourCycle::kH12;
-    case UDAT_HOUR_CYCLE_23:
-      return JSDateTimeFormat::HourCycle::kH23;
-    case UDAT_HOUR_CYCLE_24:
-      return JSDateTimeFormat::HourCycle::kH24;
-    default:
-      return JSDateTimeFormat::HourCycle::kUndefined;
-  }
-}
-
 Maybe<JSDateTimeFormat::HourCycle> GetHourCycle(Isolate* isolate,
                                                 Handle<JSReceiver> options,
                                                 const char* method) {
@@ -1576,8 +1561,9 @@ MaybeHandle<JSDateTimeFormat> JSDateTime
       generator_cache.Pointer()->CreateGenerator(icu_locale));
 
   // 15.Let hcDefault be dataLocaleData.[[hourCycle]].
-  HourCycle hc_default = ToHourCycle(generator->getDefaultHourCycle(status));
+  icu::UnicodeString hour_pattern = generator->getBestPattern("jjmm", status);
   DCHECK(U_SUCCESS(status));
+  HourCycle hc_default = HourCycleFromPattern(hour_pattern);
 
   // 16.Let hc be r.[[hc]].
   HourCycle hc = HourCycle::kUndefined;
@@ -2082,55 +2068,12 @@ Maybe<bool> AddPartForFormatRange(Isolat
 // A helper function to convert the FormattedDateInterval to a
 // MaybeHandle<JSArray> for the implementation of formatRangeToParts.
 MaybeHandle<JSArray> FormattedDateIntervalToJSArray(
-    Isolate* isolate, const icu::FormattedValue& formatted) {
-  UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString result = formatted.toString(status);
+    Isolate* isolate, const icu::DateInterval& interval, const icu::DateIntervalFormat& format) {
 
   Factory* factory = isolate->factory();
   Handle<JSArray> array = factory->NewJSArray(0);
-  icu::ConstrainedFieldPosition cfpos;
-  int index = 0;
-  int32_t previous_end_pos = 0;
-  SourceTracker tracker;
-  while (formatted.nextPosition(cfpos, status)) {
-    int32_t category = cfpos.getCategory();
-    int32_t field = cfpos.getField();
-    int32_t start = cfpos.getStart();
-    int32_t limit = cfpos.getLimit();
-
-    if (category == UFIELD_CATEGORY_DATE_INTERVAL_SPAN) {
-      DCHECK_LE(field, 2);
-      tracker.Add(field, start, limit);
-    } else {
-      DCHECK(category == UFIELD_CATEGORY_DATE);
-      if (start > previous_end_pos) {
-        // Add "literal" from the previous end position to the start if
-        // necessary.
-        Maybe<bool> maybe_added =
-            AddPartForFormatRange(isolate, array, result, index, -1,
-                                  previous_end_pos, start, tracker);
-        MAYBE_RETURN(maybe_added, Handle<JSArray>());
-        previous_end_pos = start;
-        index++;
-      }
-      Maybe<bool> maybe_added = AddPartForFormatRange(
-          isolate, array, result, index, field, start, limit, tracker);
-      MAYBE_RETURN(maybe_added, Handle<JSArray>());
-      previous_end_pos = limit;
-      ++index;
-    }
-  }
-  int32_t end = result.length();
-  // Add "literal" in the end if necessary.
-  if (end > previous_end_pos) {
-    Maybe<bool> maybe_added = AddPartForFormatRange(
-        isolate, array, result, index, -1, previous_end_pos, end, tracker);
-    MAYBE_RETURN(maybe_added, Handle<JSArray>());
-  }
-
-  if (U_FAILURE(status)) {
-    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), JSArray);
-  }
+  // TODO(ftang) To be implemented after ICU64 landed that support
+  // DateIntervalFormat::formatToValue() and FormattedDateInterval.
 
   JSObject::ValidateElements(*array);
   return array;
@@ -2141,7 +2084,7 @@ template <typename T>
 MaybeHandle<T> FormatRangeCommon(
     Isolate* isolate, Handle<JSDateTimeFormat> date_time_format, double x,
     double y,
-    MaybeHandle<T> (*formatToResult)(Isolate*, const icu::FormattedValue&)) {
+    MaybeHandle<T> (*formatToResult)(Isolate*, const icu::DateInterval&, const icu::DateIntervalFormat&)) {
   // Track newer feature formateRange and formatRangeToParts
   isolate->CountUsage(v8::Isolate::UseCounterFeature::kDateTimeFormatRange);
 
@@ -2176,15 +2119,11 @@ MaybeHandle<T> FormatRangeCommon(
   std::unique_ptr<icu::Calendar> c2(calendar->clone());
   c1->setTime(x, status);
   c2->setTime(y, status);
-  // We need to format by Calendar because we need the Gregorian change
-  // adjustment already in the SimpleDateFormat to set the correct value of date
-  // older than Oct 15, 1582.
-  icu::FormattedDateInterval formatted =
-      format->formatToValue(*c1, *c2, status);
+  icu::DateInterval interval(x, y);
   if (U_FAILURE(status)) {
     THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), T);
   }
-  return formatToResult(isolate, formatted);
+  return formatToResult(isolate, interval, *format);
 }
 
 }  // namespace
@@ -2193,7 +2132,7 @@ MaybeHandle<String> JSDateTimeFormat::Fo
     Isolate* isolate, Handle<JSDateTimeFormat> date_time_format, double x,
     double y) {
   return FormatRangeCommon<String>(isolate, date_time_format, x, y,
-                                   Intl::FormattedToString);
+                                   Intl::FormattedDateIntervalToString);
 }
 
 MaybeHandle<JSArray> JSDateTimeFormat::FormatRangeToParts(
--- a/v8/src/objects/js-number-format.cc
+++ b/v8/src/objects/js-number-format.cc
@@ -1090,7 +1090,7 @@ MaybeHandle<JSNumberFormat> JSNumberForm
 
   if (style == Style::PERCENT) {
     icu_number_formatter =
-        icu_number_formatter.unit(icu::MeasureUnit::getPercent())
+        icu_number_formatter.unit(icu::NoUnit::percent())
             .scale(icu::number::Scale::powerOfTen(2));
   }
 
@@ -1261,11 +1261,12 @@ MaybeHandle<String> JSNumberFormat::Form
     Handle<Object> numeric_obj) {
   DCHECK(numeric_obj->IsNumeric());
 
-  icu::number::FormattedNumber formatted;
+  UErrorCode status = U_ZERO_ERROR;
+  icu::number::LocalizedNumberFormatter formatter;
+  icu::number::FormattedNumber formatted = formatter.formatInt(0, status);
   Maybe<bool> maybe_format =
       IcuFormatNumber(isolate, number_format, numeric_obj, &formatted);
   MAYBE_RETURN(maybe_format, Handle<String>());
-  UErrorCode status = U_ZERO_ERROR;
   icu::UnicodeString result = formatted.toString(status);
   if (U_FAILURE(status)) {
     THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), String);
@@ -1406,12 +1407,20 @@ Maybe<int> ConstructParts(Isolate* isola
   regions.push_back(NumberFormatSpan(-1, 0, formatted_text.length()));
 
   {
+#if U_ICU_VERSION_MAJOR_NUM >= 64
     icu::ConstrainedFieldPosition cfp;
     cfp.constrainCategory(UFIELD_CATEGORY_NUMBER);
     while (formatted->nextPosition(cfp, status)) {
       regions.push_back(
           NumberFormatSpan(cfp.getField(), cfp.getStart(), cfp.getLimit()));
     }
+#else
+    icu::FieldPosition fp;
+    while (formatted->nextFieldPosition(fp, status)) {
+      regions.push_back(NumberFormatSpan(fp.getField(), fp.getBeginIndex(),
+                                         fp.getEndIndex()));
+    }
+#endif
   }
 
   std::vector<NumberFormatSpan> parts = FlattenRegionsToParts(&regions);
@@ -1443,6 +1452,25 @@ Maybe<int> ConstructParts(Isolate* isola
 
 }  // namespace
 
+// From chromium 74
+Maybe<int> JSNumberFormat::FormatToParts(Isolate* isolate,
+                                         Handle<JSArray> result,
+                                         int start_index,
+                                         const icu::number::LocalizedNumberFormatter& number_format,
+                                         Handle<Object> numeric_obj,
+                                         Handle<String> unit) {
+  DCHECK(numeric_obj->IsNumeric());
+
+  UErrorCode status = U_ZERO_ERROR;
+  icu::number::LocalizedNumberFormatter formatter;
+  icu::number::FormattedNumber formatted = formatter.formatInt(0, status);
+  Maybe<bool> maybe_format =
+      IcuFormatNumber(isolate, number_format, numeric_obj, &formatted);
+  MAYBE_RETURN(maybe_format, Nothing<int>());
+  return ConstructParts(isolate, &formatted, result,
+                        start_index, numeric_obj, !unit.is_null());
+}
+
 MaybeHandle<JSArray> JSNumberFormat::FormatToParts(
     Isolate* isolate, Handle<JSNumberFormat> number_format,
     Handle<Object> numeric_obj) {
@@ -1452,11 +1480,12 @@ MaybeHandle<JSArray> JSNumberFormat::For
       number_format->icu_number_formatter().raw();
   CHECK_NOT_NULL(fmt);
 
-  icu::number::FormattedNumber formatted;
+  UErrorCode status = U_ZERO_ERROR;
+  icu::number::LocalizedNumberFormatter formatter;
+  icu::number::FormattedNumber formatted = formatter.formatInt(0, status);
   Maybe<bool> maybe_format =
       IcuFormatNumber(isolate, *fmt, numeric_obj, &formatted);
   MAYBE_RETURN(maybe_format, Handle<JSArray>());
-  UErrorCode status = U_ZERO_ERROR;
 
   bool style_is_unit =
       Style::UNIT == StyleFromSkeleton(fmt->toSkeleton(status));
--- a/v8/src/objects/js-number-format.h
+++ b/v8/src/objects/js-number-format.h
@@ -54,6 +54,12 @@ class JSNumberFormat
       Isolate* isolate, Handle<JSNumberFormat> number_format,
       Handle<Object> numeric_obj);
 
+  // From chromium 74
+  V8_WARN_UNUSED_RESULT static Maybe<int> FormatToParts(
+      Isolate* isolate, Handle<JSArray> result, int start_index,
+      const icu::number::LocalizedNumberFormatter& number_format,
+      Handle<Object> numeric_obj, Handle<String> unit);
+
   V8_WARN_UNUSED_RESULT static MaybeHandle<String> FormatNumeric(
       Isolate* isolate,
       const icu::number::LocalizedNumberFormatter& number_format,
--- a/v8/src/objects/js-plural-rules.cc
+++ b/v8/src/objects/js-plural-rules.cc
@@ -195,9 +195,7 @@ MaybeHandle<String> JSPluralRules::Resol
       fmt->formatDouble(number, status);
   DCHECK(U_SUCCESS(status));
 
-  icu::UnicodeString result =
-      icu_plural_rules->select(formatted_number, status);
-  DCHECK(U_SUCCESS(status));
+  icu::UnicodeString result = icu_plural_rules->select(number);
 
   return Intl::ToString(isolate, result);
 }
--- a/v8/src/objects/js-display-names.cc
+++ b/v8/src/objects/js-display-names.cc
@@ -11,6 +11,7 @@
 
 #include "src/objects/js-display-names-inl.h"
 #include "src/objects/js-display-names.h"
+#include "src/objects/js-locale.h"
 
 #include "src/execution/isolate.h"
 #include "src/heap/factory.h"
@@ -20,7 +21,6 @@
 
 #include "unicode/dtfmtsym.h"
 #include "unicode/dtptngen.h"
-#include "unicode/localebuilder.h"
 #include "unicode/locdspnm.h"
 #include "unicode/timezone.h"
 #include "unicode/tznames.h"
@@ -48,20 +48,6 @@ enum class Type {
   kDateTimeField
 };
 
-bool IsUnicodeScriptSubtag(const std::string& value) {
-  UErrorCode status = U_ZERO_ERROR;
-  icu::LocaleBuilder builder;
-  builder.setScript(value).build(status);
-  return U_SUCCESS(status);
-}
-
-bool IsUnicodeRegionSubtag(const std::string& value) {
-  UErrorCode status = U_ZERO_ERROR;
-  icu::LocaleBuilder builder;
-  builder.setRegion(value).build(status);
-  return U_SUCCESS(status);
-}
-
 UDisplayContext ToUDisplayContext(JSDisplayNames::Style style) {
   switch (style) {
     case JSDisplayNames::Style::kLong:
--- a/v8/src/objects/js-locale.h
+++ b/v8/src/objects/js-locale.h
@@ -25,6 +25,9 @@ class Locale;
 namespace v8 {
 namespace internal {
 
+bool IsUnicodeScriptSubtag(const std::string& value);
+bool IsUnicodeRegionSubtag(const std::string& value);
+
 #include "torque-generated/src/objects/js-locale-tq.inc"
 
 class JSLocale : public TorqueGeneratedJSLocale<JSLocale, JSObject> {
--- a/base/i18n/icu_util.cc
+++ b/base/i18n/icu_util.cc
@@ -371,6 +371,8 @@ enum class ICUCreateInstance {
   kMaxValue = kChineseJapaneseBreakEngine
 };
 
+#if 0
+
 // Callback functions to report the opening of ICU Data File, and creation of
 // key objects to UMA. This help us to understand what built-in ICU data files
 // are rarely used in the user's machines and the distribution of ICU usage.
@@ -482,6 +484,8 @@ static void U_CALLCONV TraceICUData(cons
   }
 }
 
+#endif
+
 // Common initialization to run regardless of how ICU is initialized.
 // There are multiple exposed InitializeIcu* functions. This should be called
 // as at the end of (the last functions in the sequence of) these functions.
@@ -491,8 +495,6 @@ bool DoCommonInitialization() {
   // when requested.
   InitializeIcuTimeZone();
 
-  const void* context = nullptr;
-  utrace_setFunctions(context, TraceICUEntry, nullptr, TraceICUData);
   utrace_setLevel(UTRACE_VERBOSE);
   return true;
 }

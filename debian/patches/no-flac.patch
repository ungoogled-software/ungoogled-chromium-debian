Index: chromium/content/content_browser.gypi
===================================================================
--- chromium.orig/content/content_browser.gypi
+++ chromium/content/content_browser.gypi
@@ -1706,7 +1706,6 @@
     }],
     ['input_speech==1', {
       'dependencies': [
-        '../third_party/flac/flac.gyp:libflac',
         '../third_party/speex/speex.gyp:libspeex',
       ],
     }],
Index: chromium/content/browser/speech/audio_encoder.cc
===================================================================
--- chromium.orig/content/browser/speech/audio_encoder.cc
+++ chromium/content/browser/speech/audio_encoder.cc
@@ -10,96 +10,11 @@
 #include "base/stl_util.h"
 #include "base/strings/string_number_conversions.h"
 #include "content/browser/speech/audio_buffer.h"
-#include "third_party/flac/include/FLAC/stream_encoder.h"
 #include "third_party/speex/include/speex/speex.h"
 
 namespace content {
 namespace {
 
-//-------------------------------- FLACEncoder ---------------------------------
-
-const char* const kContentTypeFLAC = "audio/x-flac; rate=";
-const int kFLACCompressionLevel = 0;  // 0 for speed
-
-class FLACEncoder : public AudioEncoder {
- public:
-  FLACEncoder(int sampling_rate, int bits_per_sample);
-  virtual ~FLACEncoder();
-  virtual void Encode(const AudioChunk& raw_audio) OVERRIDE;
-  virtual void Flush() OVERRIDE;
-
- private:
-  static FLAC__StreamEncoderWriteStatus WriteCallback(
-      const FLAC__StreamEncoder* encoder,
-      const FLAC__byte buffer[],
-      size_t bytes,
-      unsigned samples,
-      unsigned current_frame,
-      void* client_data);
-
-  FLAC__StreamEncoder* encoder_;
-  bool is_encoder_initialized_;
-
-  DISALLOW_COPY_AND_ASSIGN(FLACEncoder);
-};
-
-FLAC__StreamEncoderWriteStatus FLACEncoder::WriteCallback(
-    const FLAC__StreamEncoder* encoder,
-    const FLAC__byte buffer[],
-    size_t bytes,
-    unsigned samples,
-    unsigned current_frame,
-    void* client_data) {
-  FLACEncoder* me = static_cast<FLACEncoder*>(client_data);
-  DCHECK(me->encoder_ == encoder);
-  me->encoded_audio_buffer_.Enqueue(buffer, bytes);
-  return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
-}
-
-FLACEncoder::FLACEncoder(int sampling_rate, int bits_per_sample)
-    : AudioEncoder(std::string(kContentTypeFLAC) +
-                   base::IntToString(sampling_rate),
-                   bits_per_sample),
-      encoder_(FLAC__stream_encoder_new()),
-      is_encoder_initialized_(false) {
-  FLAC__stream_encoder_set_channels(encoder_, 1);
-  FLAC__stream_encoder_set_bits_per_sample(encoder_, bits_per_sample);
-  FLAC__stream_encoder_set_sample_rate(encoder_, sampling_rate);
-  FLAC__stream_encoder_set_compression_level(encoder_, kFLACCompressionLevel);
-
-  // Initializing the encoder will cause sync bytes to be written to
-  // its output stream, so we wait until the first call to this method
-  // before doing so.
-}
-
-FLACEncoder::~FLACEncoder() {
-  FLAC__stream_encoder_delete(encoder_);
-}
-
-void FLACEncoder::Encode(const AudioChunk& raw_audio) {
-  DCHECK_EQ(raw_audio.bytes_per_sample(), 2);
-  if (!is_encoder_initialized_) {
-    const FLAC__StreamEncoderInitStatus encoder_status =
-        FLAC__stream_encoder_init_stream(encoder_, WriteCallback, NULL, NULL,
-                                         NULL, this);
-    DCHECK_EQ(encoder_status, FLAC__STREAM_ENCODER_INIT_STATUS_OK);
-    is_encoder_initialized_ = true;
-  }
-
-  // FLAC encoder wants samples as int32s.
-  const int num_samples = raw_audio.NumSamples();
-  scoped_ptr<FLAC__int32[]> flac_samples(new FLAC__int32[num_samples]);
-  FLAC__int32* flac_samples_ptr = flac_samples.get();
-  for (int i = 0; i < num_samples; ++i)
-    flac_samples_ptr[i] = static_cast<FLAC__int32>(raw_audio.GetSample16(i));
-
-  FLAC__stream_encoder_process(encoder_, &flac_samples_ptr, num_samples);
-}
-
-void FLACEncoder::Flush() {
-  FLAC__stream_encoder_finish(encoder_);
-}
-
 //-------------------------------- SpeexEncoder --------------------------------
 
 const char* const kContentTypeSpeex = "audio/x-speex-with-header-byte; rate=";
@@ -173,8 +88,6 @@ void SpeexEncoder::Encode(const AudioChu
 AudioEncoder* AudioEncoder::Create(Codec codec,
                                    int sampling_rate,
                                    int bits_per_sample) {
-  if (codec == CODEC_FLAC)
-    return new FLACEncoder(sampling_rate, bits_per_sample);
   return new SpeexEncoder(sampling_rate, bits_per_sample);
 }
 
Index: chromium/content/browser/speech/audio_encoder.h
===================================================================
--- chromium.orig/content/browser/speech/audio_encoder.h
+++ chromium/content/browser/speech/audio_encoder.h
@@ -20,7 +20,6 @@ class AudioChunk;
 class AudioEncoder {
  public:
   enum Codec {
-    CODEC_FLAC,
     CODEC_SPEEX,
   };
 
Index: chromium/content/browser/speech/google_one_shot_remote_engine.cc
===================================================================
--- chromium.orig/content/browser/speech/google_one_shot_remote_engine.cc
+++ chromium/content/browser/speech/google_one_shot_remote_engine.cc
@@ -34,7 +34,7 @@ const char* const kConfidenceString = "c
 const int kWebServiceStatusNoError = 0;
 const int kWebServiceStatusNoSpeech = 4;
 const int kWebServiceStatusNoMatch = 5;
-const AudioEncoder::Codec kDefaultAudioCodec = AudioEncoder::CODEC_FLAC;
+const AudioEncoder::Codec kDefaultAudioCodec = AudioEncoder::CODEC_SPEEX;
 
 bool ParseServerResponse(const std::string& response_body,
                          SpeechRecognitionResult* result,
Index: chromium/content/browser/speech/google_streaming_remote_engine.cc
===================================================================
--- chromium.orig/content/browser/speech/google_streaming_remote_engine.cc
+++ chromium/content/browser/speech/google_streaming_remote_engine.cc
@@ -35,7 +35,7 @@ const char kWebServiceBaseUrl[] =
     "https://www.google.com/speech-api/full-duplex/v1";
 const char kDownstreamUrl[] = "/down?";
 const char kUpstreamUrl[] = "/up?";
-const AudioEncoder::Codec kDefaultAudioCodec = AudioEncoder::CODEC_FLAC;
+const AudioEncoder::Codec kDefaultAudioCodec = AudioEncoder::CODEC_SPEEX;
 
 // This matches the maximum maxAlternatives value supported by the server.
 const uint32 kMaxMaxAlternatives = 30;

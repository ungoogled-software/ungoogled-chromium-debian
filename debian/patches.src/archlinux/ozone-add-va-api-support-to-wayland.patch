From: Maksim Sisov <msisov@igalia.com>
Date: Wed, 20 Jan 2021 09:50:22 +0200
Subject: [PATCH] ozone/wayland: add VA-API support.

This patch ads VA-API support utilizing old VA-API path used for
ChromeOS, which can be buggy on some devices (currently tested
on Intel Gen8 and Gen9 with Gen8 having some minor bugs).

It's known that a new VA-API is being developed atm and once it's ready,
we will switch to a new path, which should be more stable.

Upstream-Status: Inappropriate

The patch is based on the old va-api path. ChromeOS
team is working on the new path, which will be also employed
by Wayland later.

---
--- a/media/gpu/vaapi/vaapi_picture_factory.cc
+++ b/media/gpu/vaapi/vaapi_picture_factory.cc
@@ -105,7 +105,7 @@ uint32_t VaapiPictureFactory::GetGLTextu
 }
 
 gfx::BufferFormat VaapiPictureFactory::GetBufferFormat() {
-#if BUILDFLAG(USE_VAAPI_X11)
+#if BUILDFLAG(IS_LINUX)
   return gfx::BufferFormat::RGBX_8888;
 #else
   return gfx::BufferFormat::YUV_420_BIPLANAR;
--- a/media/gpu/vaapi/vaapi_picture_native_pixmap.cc
+++ b/media/gpu/vaapi/vaapi_picture_native_pixmap.cc
@@ -4,6 +4,7 @@
 
 #include "media/gpu/vaapi/vaapi_picture_native_pixmap.h"
 
+#include "media/gpu/macros.h"
 #include "media/gpu/vaapi/va_surface.h"
 #include "media/gpu/vaapi/vaapi_wrapper.h"
 #include "ui/gfx/buffer_format_util.h"
@@ -40,7 +41,21 @@ VaapiPictureNativePixmap::~VaapiPictureN
 bool VaapiPictureNativePixmap::DownloadFromSurface(
     scoped_refptr<VASurface> va_surface) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  return vaapi_wrapper_->BlitSurface(*va_surface, *va_surface_);
+  if (!vaapi_wrapper_->SyncSurface(va_surface->id())) {
+    VLOGF(1) << "Cannot sync VPP input surface";
+    return false;
+  }
+  if (!vaapi_wrapper_->BlitSurface(*va_surface, *va_surface_)) {
+    VLOGF(1) << "Cannot convert decoded image into output buffer";
+    return false;
+  }
+
+  // Sync target surface since the buffer is returning to client.
+  if (!vaapi_wrapper_->SyncSurface(va_surface_->id())) {
+    VLOGF(1) << "Cannot sync VPP output surface";
+    return false;
+  }
+  return true;
 }
 
 bool VaapiPictureNativePixmap::AllowOverlay() const {
--- a/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
+++ b/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
@@ -560,12 +560,12 @@ void VaapiVideoDecodeAccelerator::Initia
   requested_visible_rect_ = visible_rect;
   if (buffer_allocation_mode_ == BufferAllocationMode::kSuperReduced) {
     // Add one to the reference frames for the one being currently egressed.
-    requested_num_reference_frames_ = num_reference_frames + 1;
+    requested_num_reference_frames_ = num_reference_frames + 4;
     requested_num_pics_ = num_pics - num_reference_frames;
   } else if (buffer_allocation_mode_ == BufferAllocationMode::kReduced) {
     // Add one to the reference frames for the one being currently egressed,
     // and an extra allocation for both |client_| and |decoder_|.
-    requested_num_reference_frames_ = num_reference_frames + 2;
+    requested_num_reference_frames_ = num_reference_frames + 5;
     requested_num_pics_ = num_pics - num_reference_frames + 1;
   } else {
     requested_num_reference_frames_ = 0;
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.cc
@@ -32,7 +32,9 @@ GbmPixmapWayland::GbmPixmapWayland(Wayla
       buffer_id_(buffer_manager->AllocateBufferID()) {}
 
 GbmPixmapWayland::~GbmPixmapWayland() {
-  if (created_wl_buffer_)
+  // gfx::BufferUsage::SCANOUT_VDA_WRITE doesn't result in creation of
+  // wl_buffers.
+  if (created_wl_buffer_ && usage_ != gfx::BufferUsage::SCANOUT_VDA_WRITE)
     buffer_manager_->DestroyBuffer(buffer_id_);
 }
 
--- a/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h
+++ b/ui/ozone/platform/wayland/gpu/gbm_pixmap_wayland.h
@@ -92,6 +92,9 @@ class GbmPixmapWayland : public gfx::Nat
 
   // Says a wl_buffer has been created and must removed.
   bool created_wl_buffer_ = false;
+
+  // Tells the usage of this pixmap.
+  gfx::BufferUsage usage_ = gfx::BufferUsage::SCANOUT;
 };
 
 }  // namespace ui
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
@@ -295,6 +295,9 @@ class OzonePlatformWayland : public Ozon
       properties->supports_global_screen_coordinates =
           features::IsWaylandScreenCoordinatesEnabled();
 
+      // Let the media know this platform supports va-api.
+      properties->supports_vaapi = true;
+
       initialised = true;
     }
 
